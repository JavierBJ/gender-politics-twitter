# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_freeling', [dirname(__file__)])
        except ImportError:
            import _freeling
            return _freeling
        if fp is not None:
            try:
                _mod = imp.load_module('_freeling', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _freeling = swig_import_helper()
    del swig_import_helper
else:
    import _freeling
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _freeling.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _freeling.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _freeling.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _freeling.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _freeling.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _freeling.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _freeling.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _freeling.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _freeling.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _freeling.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _freeling.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _freeling.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _freeling.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _freeling.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _freeling.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _freeling.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _freeling.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _freeling.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class VectorWord(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorWord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorWord, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.VectorWord_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.VectorWord___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.VectorWord___bool__(self)

    def __len__(self) -> "std::vector< freeling::word >::size_type":
        return _freeling.VectorWord___len__(self)

    def __getslice__(self, i: 'std::vector< freeling::word >::difference_type', j: 'std::vector< freeling::word >::difference_type') -> "std::vector< freeling::word,std::allocator< freeling::word > > *":
        return _freeling.VectorWord___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.VectorWord___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< freeling::word >::difference_type', j: 'std::vector< freeling::word >::difference_type') -> "void":
        return _freeling.VectorWord___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.VectorWord___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< freeling::word >::value_type const &":
        return _freeling.VectorWord___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.VectorWord___setitem__(self, *args)

    def pop(self) -> "std::vector< freeling::word >::value_type":
        return _freeling.VectorWord_pop(self)

    def append(self, x: 'word') -> "void":
        return _freeling.VectorWord_append(self, x)

    def empty(self) -> "bool":
        return _freeling.VectorWord_empty(self)

    def size(self) -> "std::vector< freeling::word >::size_type":
        return _freeling.VectorWord_size(self)

    def swap(self, v: 'VectorWord') -> "void":
        return _freeling.VectorWord_swap(self, v)

    def begin(self) -> "std::vector< freeling::word >::iterator":
        return _freeling.VectorWord_begin(self)

    def end(self) -> "std::vector< freeling::word >::iterator":
        return _freeling.VectorWord_end(self)

    def rbegin(self) -> "std::vector< freeling::word >::reverse_iterator":
        return _freeling.VectorWord_rbegin(self)

    def rend(self) -> "std::vector< freeling::word >::reverse_iterator":
        return _freeling.VectorWord_rend(self)

    def clear(self) -> "void":
        return _freeling.VectorWord_clear(self)

    def get_allocator(self) -> "std::vector< freeling::word >::allocator_type":
        return _freeling.VectorWord_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.VectorWord_pop_back(self)

    def erase(self, *args) -> "std::vector< freeling::word >::iterator":
        return _freeling.VectorWord_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_VectorWord(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'word') -> "void":
        return _freeling.VectorWord_push_back(self, x)

    def front(self) -> "std::vector< freeling::word >::value_type const &":
        return _freeling.VectorWord_front(self)

    def back(self) -> "std::vector< freeling::word >::value_type const &":
        return _freeling.VectorWord_back(self)

    def assign(self, n: 'std::vector< freeling::word >::size_type', x: 'word') -> "void":
        return _freeling.VectorWord_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.VectorWord_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.VectorWord_insert(self, *args)

    def reserve(self, n: 'std::vector< freeling::word >::size_type') -> "void":
        return _freeling.VectorWord_reserve(self, n)

    def capacity(self) -> "std::vector< freeling::word >::size_type":
        return _freeling.VectorWord_capacity(self)
    __swig_destroy__ = _freeling.delete_VectorWord
    __del__ = lambda self: None
VectorWord_swigregister = _freeling.VectorWord_swigregister
VectorWord_swigregister(VectorWord)

class ListWord(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListWord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ListWord, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.ListWord_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.ListWord___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.ListWord___bool__(self)

    def __len__(self) -> "std::list< freeling::word >::size_type":
        return _freeling.ListWord___len__(self)

    def __getslice__(self, i: 'std::list< freeling::word >::difference_type', j: 'std::list< freeling::word >::difference_type') -> "std::list< freeling::word,std::allocator< freeling::word > > *":
        return _freeling.ListWord___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.ListWord___setslice__(self, *args)

    def __delslice__(self, i: 'std::list< freeling::word >::difference_type', j: 'std::list< freeling::word >::difference_type') -> "void":
        return _freeling.ListWord___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.ListWord___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< freeling::word >::value_type const &":
        return _freeling.ListWord___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.ListWord___setitem__(self, *args)

    def pop(self) -> "std::list< freeling::word >::value_type":
        return _freeling.ListWord_pop(self)

    def append(self, x: 'word') -> "void":
        return _freeling.ListWord_append(self, x)

    def empty(self) -> "bool":
        return _freeling.ListWord_empty(self)

    def size(self) -> "std::list< freeling::word >::size_type":
        return _freeling.ListWord_size(self)

    def swap(self, v: 'ListWord') -> "void":
        return _freeling.ListWord_swap(self, v)

    def begin(self) -> "std::list< freeling::word >::iterator":
        return _freeling.ListWord_begin(self)

    def end(self) -> "std::list< freeling::word >::iterator":
        return _freeling.ListWord_end(self)

    def rbegin(self) -> "std::list< freeling::word >::reverse_iterator":
        return _freeling.ListWord_rbegin(self)

    def rend(self) -> "std::list< freeling::word >::reverse_iterator":
        return _freeling.ListWord_rend(self)

    def clear(self) -> "void":
        return _freeling.ListWord_clear(self)

    def get_allocator(self) -> "std::list< freeling::word >::allocator_type":
        return _freeling.ListWord_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.ListWord_pop_back(self)

    def erase(self, *args) -> "std::list< freeling::word >::iterator":
        return _freeling.ListWord_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_ListWord(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'word') -> "void":
        return _freeling.ListWord_push_back(self, x)

    def front(self) -> "std::list< freeling::word >::value_type const &":
        return _freeling.ListWord_front(self)

    def back(self) -> "std::list< freeling::word >::value_type const &":
        return _freeling.ListWord_back(self)

    def assign(self, n: 'std::list< freeling::word >::size_type', x: 'word') -> "void":
        return _freeling.ListWord_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.ListWord_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.ListWord_insert(self, *args)

    def pop_front(self) -> "void":
        return _freeling.ListWord_pop_front(self)

    def push_front(self, x: 'word') -> "void":
        return _freeling.ListWord_push_front(self, x)

    def reverse(self) -> "void":
        return _freeling.ListWord_reverse(self)
    __swig_destroy__ = _freeling.delete_ListWord
    __del__ = lambda self: None
ListWord_swigregister = _freeling.ListWord_swigregister
ListWord_swigregister(ListWord)

class ListAnalysis(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListAnalysis, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ListAnalysis, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.ListAnalysis_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.ListAnalysis___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.ListAnalysis___bool__(self)

    def __len__(self) -> "std::list< freeling::analysis >::size_type":
        return _freeling.ListAnalysis___len__(self)

    def __getslice__(self, i: 'std::list< freeling::analysis >::difference_type', j: 'std::list< freeling::analysis >::difference_type') -> "std::list< freeling::analysis,std::allocator< freeling::analysis > > *":
        return _freeling.ListAnalysis___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.ListAnalysis___setslice__(self, *args)

    def __delslice__(self, i: 'std::list< freeling::analysis >::difference_type', j: 'std::list< freeling::analysis >::difference_type') -> "void":
        return _freeling.ListAnalysis___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.ListAnalysis___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< freeling::analysis >::value_type const &":
        return _freeling.ListAnalysis___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.ListAnalysis___setitem__(self, *args)

    def pop(self) -> "std::list< freeling::analysis >::value_type":
        return _freeling.ListAnalysis_pop(self)

    def append(self, x: 'analysis') -> "void":
        return _freeling.ListAnalysis_append(self, x)

    def empty(self) -> "bool":
        return _freeling.ListAnalysis_empty(self)

    def size(self) -> "std::list< freeling::analysis >::size_type":
        return _freeling.ListAnalysis_size(self)

    def swap(self, v: 'ListAnalysis') -> "void":
        return _freeling.ListAnalysis_swap(self, v)

    def begin(self) -> "std::list< freeling::analysis >::iterator":
        return _freeling.ListAnalysis_begin(self)

    def end(self) -> "std::list< freeling::analysis >::iterator":
        return _freeling.ListAnalysis_end(self)

    def rbegin(self) -> "std::list< freeling::analysis >::reverse_iterator":
        return _freeling.ListAnalysis_rbegin(self)

    def rend(self) -> "std::list< freeling::analysis >::reverse_iterator":
        return _freeling.ListAnalysis_rend(self)

    def clear(self) -> "void":
        return _freeling.ListAnalysis_clear(self)

    def get_allocator(self) -> "std::list< freeling::analysis >::allocator_type":
        return _freeling.ListAnalysis_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.ListAnalysis_pop_back(self)

    def erase(self, *args) -> "std::list< freeling::analysis >::iterator":
        return _freeling.ListAnalysis_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_ListAnalysis(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'analysis') -> "void":
        return _freeling.ListAnalysis_push_back(self, x)

    def front(self) -> "std::list< freeling::analysis >::value_type const &":
        return _freeling.ListAnalysis_front(self)

    def back(self) -> "std::list< freeling::analysis >::value_type const &":
        return _freeling.ListAnalysis_back(self)

    def assign(self, n: 'std::list< freeling::analysis >::size_type', x: 'analysis') -> "void":
        return _freeling.ListAnalysis_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.ListAnalysis_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.ListAnalysis_insert(self, *args)

    def pop_front(self) -> "void":
        return _freeling.ListAnalysis_pop_front(self)

    def push_front(self, x: 'analysis') -> "void":
        return _freeling.ListAnalysis_push_front(self, x)

    def reverse(self) -> "void":
        return _freeling.ListAnalysis_reverse(self)
    __swig_destroy__ = _freeling.delete_ListAnalysis
    __del__ = lambda self: None
ListAnalysis_swigregister = _freeling.ListAnalysis_swigregister
ListAnalysis_swigregister(ListAnalysis)

class ListAlternative(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListAlternative, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ListAlternative, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.ListAlternative_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.ListAlternative___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.ListAlternative___bool__(self)

    def __len__(self) -> "std::list< freeling::alternative >::size_type":
        return _freeling.ListAlternative___len__(self)

    def __getslice__(self, i: 'std::list< freeling::alternative >::difference_type', j: 'std::list< freeling::alternative >::difference_type') -> "std::list< freeling::alternative,std::allocator< freeling::alternative > > *":
        return _freeling.ListAlternative___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.ListAlternative___setslice__(self, *args)

    def __delslice__(self, i: 'std::list< freeling::alternative >::difference_type', j: 'std::list< freeling::alternative >::difference_type') -> "void":
        return _freeling.ListAlternative___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.ListAlternative___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< freeling::alternative >::value_type const &":
        return _freeling.ListAlternative___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.ListAlternative___setitem__(self, *args)

    def pop(self) -> "std::list< freeling::alternative >::value_type":
        return _freeling.ListAlternative_pop(self)

    def append(self, x: 'alternative') -> "void":
        return _freeling.ListAlternative_append(self, x)

    def empty(self) -> "bool":
        return _freeling.ListAlternative_empty(self)

    def size(self) -> "std::list< freeling::alternative >::size_type":
        return _freeling.ListAlternative_size(self)

    def swap(self, v: 'ListAlternative') -> "void":
        return _freeling.ListAlternative_swap(self, v)

    def begin(self) -> "std::list< freeling::alternative >::iterator":
        return _freeling.ListAlternative_begin(self)

    def end(self) -> "std::list< freeling::alternative >::iterator":
        return _freeling.ListAlternative_end(self)

    def rbegin(self) -> "std::list< freeling::alternative >::reverse_iterator":
        return _freeling.ListAlternative_rbegin(self)

    def rend(self) -> "std::list< freeling::alternative >::reverse_iterator":
        return _freeling.ListAlternative_rend(self)

    def clear(self) -> "void":
        return _freeling.ListAlternative_clear(self)

    def get_allocator(self) -> "std::list< freeling::alternative >::allocator_type":
        return _freeling.ListAlternative_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.ListAlternative_pop_back(self)

    def erase(self, *args) -> "std::list< freeling::alternative >::iterator":
        return _freeling.ListAlternative_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_ListAlternative(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'alternative') -> "void":
        return _freeling.ListAlternative_push_back(self, x)

    def front(self) -> "std::list< freeling::alternative >::value_type const &":
        return _freeling.ListAlternative_front(self)

    def back(self) -> "std::list< freeling::alternative >::value_type const &":
        return _freeling.ListAlternative_back(self)

    def assign(self, n: 'std::list< freeling::alternative >::size_type', x: 'alternative') -> "void":
        return _freeling.ListAlternative_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.ListAlternative_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.ListAlternative_insert(self, *args)

    def pop_front(self) -> "void":
        return _freeling.ListAlternative_pop_front(self)

    def push_front(self, x: 'alternative') -> "void":
        return _freeling.ListAlternative_push_front(self, x)

    def reverse(self) -> "void":
        return _freeling.ListAlternative_reverse(self)
    __swig_destroy__ = _freeling.delete_ListAlternative
    __del__ = lambda self: None
ListAlternative_swigregister = _freeling.ListAlternative_swigregister
ListAlternative_swigregister(ListAlternative)

class ListSentence(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListSentence, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ListSentence, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.ListSentence_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.ListSentence___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.ListSentence___bool__(self)

    def __len__(self) -> "std::list< freeling::sentence >::size_type":
        return _freeling.ListSentence___len__(self)

    def __getslice__(self, i: 'std::list< freeling::sentence >::difference_type', j: 'std::list< freeling::sentence >::difference_type') -> "std::list< freeling::sentence,std::allocator< freeling::sentence > > *":
        return _freeling.ListSentence___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.ListSentence___setslice__(self, *args)

    def __delslice__(self, i: 'std::list< freeling::sentence >::difference_type', j: 'std::list< freeling::sentence >::difference_type') -> "void":
        return _freeling.ListSentence___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.ListSentence___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< freeling::sentence >::value_type const &":
        return _freeling.ListSentence___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.ListSentence___setitem__(self, *args)

    def pop(self) -> "std::list< freeling::sentence >::value_type":
        return _freeling.ListSentence_pop(self)

    def append(self, x: 'sentence') -> "void":
        return _freeling.ListSentence_append(self, x)

    def empty(self) -> "bool":
        return _freeling.ListSentence_empty(self)

    def size(self) -> "std::list< freeling::sentence >::size_type":
        return _freeling.ListSentence_size(self)

    def swap(self, v: 'ListSentence') -> "void":
        return _freeling.ListSentence_swap(self, v)

    def begin(self) -> "std::list< freeling::sentence >::iterator":
        return _freeling.ListSentence_begin(self)

    def end(self) -> "std::list< freeling::sentence >::iterator":
        return _freeling.ListSentence_end(self)

    def rbegin(self) -> "std::list< freeling::sentence >::reverse_iterator":
        return _freeling.ListSentence_rbegin(self)

    def rend(self) -> "std::list< freeling::sentence >::reverse_iterator":
        return _freeling.ListSentence_rend(self)

    def clear(self) -> "void":
        return _freeling.ListSentence_clear(self)

    def get_allocator(self) -> "std::list< freeling::sentence >::allocator_type":
        return _freeling.ListSentence_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.ListSentence_pop_back(self)

    def erase(self, *args) -> "std::list< freeling::sentence >::iterator":
        return _freeling.ListSentence_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_ListSentence(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'sentence') -> "void":
        return _freeling.ListSentence_push_back(self, x)

    def front(self) -> "std::list< freeling::sentence >::value_type const &":
        return _freeling.ListSentence_front(self)

    def back(self) -> "std::list< freeling::sentence >::value_type const &":
        return _freeling.ListSentence_back(self)

    def assign(self, n: 'std::list< freeling::sentence >::size_type', x: 'sentence') -> "void":
        return _freeling.ListSentence_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.ListSentence_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.ListSentence_insert(self, *args)

    def pop_front(self) -> "void":
        return _freeling.ListSentence_pop_front(self)

    def push_front(self, x: 'sentence') -> "void":
        return _freeling.ListSentence_push_front(self, x)

    def reverse(self) -> "void":
        return _freeling.ListSentence_reverse(self)
    __swig_destroy__ = _freeling.delete_ListSentence
    __del__ = lambda self: None
ListSentence_swigregister = _freeling.ListSentence_swigregister
ListSentence_swigregister(ListSentence)

class ListParagraph(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListParagraph, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ListParagraph, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.ListParagraph_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.ListParagraph___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.ListParagraph___bool__(self)

    def __len__(self) -> "std::list< freeling::paragraph >::size_type":
        return _freeling.ListParagraph___len__(self)

    def __getslice__(self, i: 'std::list< freeling::paragraph >::difference_type', j: 'std::list< freeling::paragraph >::difference_type') -> "std::list< freeling::paragraph,std::allocator< freeling::paragraph > > *":
        return _freeling.ListParagraph___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.ListParagraph___setslice__(self, *args)

    def __delslice__(self, i: 'std::list< freeling::paragraph >::difference_type', j: 'std::list< freeling::paragraph >::difference_type') -> "void":
        return _freeling.ListParagraph___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.ListParagraph___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< freeling::paragraph >::value_type const &":
        return _freeling.ListParagraph___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.ListParagraph___setitem__(self, *args)

    def pop(self) -> "std::list< freeling::paragraph >::value_type":
        return _freeling.ListParagraph_pop(self)

    def append(self, x: 'paragraph') -> "void":
        return _freeling.ListParagraph_append(self, x)

    def empty(self) -> "bool":
        return _freeling.ListParagraph_empty(self)

    def size(self) -> "std::list< freeling::paragraph >::size_type":
        return _freeling.ListParagraph_size(self)

    def swap(self, v: 'ListParagraph') -> "void":
        return _freeling.ListParagraph_swap(self, v)

    def begin(self) -> "std::list< freeling::paragraph >::iterator":
        return _freeling.ListParagraph_begin(self)

    def end(self) -> "std::list< freeling::paragraph >::iterator":
        return _freeling.ListParagraph_end(self)

    def rbegin(self) -> "std::list< freeling::paragraph >::reverse_iterator":
        return _freeling.ListParagraph_rbegin(self)

    def rend(self) -> "std::list< freeling::paragraph >::reverse_iterator":
        return _freeling.ListParagraph_rend(self)

    def clear(self) -> "void":
        return _freeling.ListParagraph_clear(self)

    def get_allocator(self) -> "std::list< freeling::paragraph >::allocator_type":
        return _freeling.ListParagraph_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.ListParagraph_pop_back(self)

    def erase(self, *args) -> "std::list< freeling::paragraph >::iterator":
        return _freeling.ListParagraph_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_ListParagraph(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'paragraph') -> "void":
        return _freeling.ListParagraph_push_back(self, x)

    def front(self) -> "std::list< freeling::paragraph >::value_type const &":
        return _freeling.ListParagraph_front(self)

    def back(self) -> "std::list< freeling::paragraph >::value_type const &":
        return _freeling.ListParagraph_back(self)

    def assign(self, n: 'std::list< freeling::paragraph >::size_type', x: 'paragraph') -> "void":
        return _freeling.ListParagraph_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.ListParagraph_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.ListParagraph_insert(self, *args)

    def pop_front(self) -> "void":
        return _freeling.ListParagraph_pop_front(self)

    def push_front(self, x: 'paragraph') -> "void":
        return _freeling.ListParagraph_push_front(self, x)

    def reverse(self) -> "void":
        return _freeling.ListParagraph_reverse(self)
    __swig_destroy__ = _freeling.delete_ListParagraph
    __del__ = lambda self: None
ListParagraph_swigregister = _freeling.ListParagraph_swigregister
ListParagraph_swigregister(ListParagraph)

class VectorArgument(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorArgument, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorArgument, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.VectorArgument_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.VectorArgument___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.VectorArgument___bool__(self)

    def __len__(self) -> "std::vector< freeling::argument >::size_type":
        return _freeling.VectorArgument___len__(self)

    def __getslice__(self, i: 'std::vector< freeling::argument >::difference_type', j: 'std::vector< freeling::argument >::difference_type') -> "std::vector< freeling::argument,std::allocator< freeling::argument > > *":
        return _freeling.VectorArgument___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.VectorArgument___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< freeling::argument >::difference_type', j: 'std::vector< freeling::argument >::difference_type') -> "void":
        return _freeling.VectorArgument___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.VectorArgument___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< freeling::argument >::value_type const &":
        return _freeling.VectorArgument___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.VectorArgument___setitem__(self, *args)

    def pop(self) -> "std::vector< freeling::argument >::value_type":
        return _freeling.VectorArgument_pop(self)

    def append(self, x: 'argument') -> "void":
        return _freeling.VectorArgument_append(self, x)

    def empty(self) -> "bool":
        return _freeling.VectorArgument_empty(self)

    def size(self) -> "std::vector< freeling::argument >::size_type":
        return _freeling.VectorArgument_size(self)

    def swap(self, v: 'VectorArgument') -> "void":
        return _freeling.VectorArgument_swap(self, v)

    def begin(self) -> "std::vector< freeling::argument >::iterator":
        return _freeling.VectorArgument_begin(self)

    def end(self) -> "std::vector< freeling::argument >::iterator":
        return _freeling.VectorArgument_end(self)

    def rbegin(self) -> "std::vector< freeling::argument >::reverse_iterator":
        return _freeling.VectorArgument_rbegin(self)

    def rend(self) -> "std::vector< freeling::argument >::reverse_iterator":
        return _freeling.VectorArgument_rend(self)

    def clear(self) -> "void":
        return _freeling.VectorArgument_clear(self)

    def get_allocator(self) -> "std::vector< freeling::argument >::allocator_type":
        return _freeling.VectorArgument_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.VectorArgument_pop_back(self)

    def erase(self, *args) -> "std::vector< freeling::argument >::iterator":
        return _freeling.VectorArgument_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_VectorArgument(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'argument') -> "void":
        return _freeling.VectorArgument_push_back(self, x)

    def front(self) -> "std::vector< freeling::argument >::value_type const &":
        return _freeling.VectorArgument_front(self)

    def back(self) -> "std::vector< freeling::argument >::value_type const &":
        return _freeling.VectorArgument_back(self)

    def assign(self, n: 'std::vector< freeling::argument >::size_type', x: 'argument') -> "void":
        return _freeling.VectorArgument_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.VectorArgument_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.VectorArgument_insert(self, *args)

    def reserve(self, n: 'std::vector< freeling::argument >::size_type') -> "void":
        return _freeling.VectorArgument_reserve(self, n)

    def capacity(self) -> "std::vector< freeling::argument >::size_type":
        return _freeling.VectorArgument_capacity(self)
    __swig_destroy__ = _freeling.delete_VectorArgument
    __del__ = lambda self: None
VectorArgument_swigregister = _freeling.VectorArgument_swigregister
VectorArgument_swigregister(VectorArgument)

class VectorPredicate(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorPredicate, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorPredicate, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.VectorPredicate_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.VectorPredicate___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.VectorPredicate___bool__(self)

    def __len__(self) -> "std::vector< freeling::predicate >::size_type":
        return _freeling.VectorPredicate___len__(self)

    def __getslice__(self, i: 'std::vector< freeling::predicate >::difference_type', j: 'std::vector< freeling::predicate >::difference_type') -> "std::vector< freeling::predicate,std::allocator< freeling::predicate > > *":
        return _freeling.VectorPredicate___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.VectorPredicate___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< freeling::predicate >::difference_type', j: 'std::vector< freeling::predicate >::difference_type') -> "void":
        return _freeling.VectorPredicate___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.VectorPredicate___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< freeling::predicate >::value_type const &":
        return _freeling.VectorPredicate___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.VectorPredicate___setitem__(self, *args)

    def pop(self) -> "std::vector< freeling::predicate >::value_type":
        return _freeling.VectorPredicate_pop(self)

    def append(self, x: 'predicate') -> "void":
        return _freeling.VectorPredicate_append(self, x)

    def empty(self) -> "bool":
        return _freeling.VectorPredicate_empty(self)

    def size(self) -> "std::vector< freeling::predicate >::size_type":
        return _freeling.VectorPredicate_size(self)

    def swap(self, v: 'VectorPredicate') -> "void":
        return _freeling.VectorPredicate_swap(self, v)

    def begin(self) -> "std::vector< freeling::predicate >::iterator":
        return _freeling.VectorPredicate_begin(self)

    def end(self) -> "std::vector< freeling::predicate >::iterator":
        return _freeling.VectorPredicate_end(self)

    def rbegin(self) -> "std::vector< freeling::predicate >::reverse_iterator":
        return _freeling.VectorPredicate_rbegin(self)

    def rend(self) -> "std::vector< freeling::predicate >::reverse_iterator":
        return _freeling.VectorPredicate_rend(self)

    def clear(self) -> "void":
        return _freeling.VectorPredicate_clear(self)

    def get_allocator(self) -> "std::vector< freeling::predicate >::allocator_type":
        return _freeling.VectorPredicate_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.VectorPredicate_pop_back(self)

    def erase(self, *args) -> "std::vector< freeling::predicate >::iterator":
        return _freeling.VectorPredicate_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_VectorPredicate(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'predicate') -> "void":
        return _freeling.VectorPredicate_push_back(self, x)

    def front(self) -> "std::vector< freeling::predicate >::value_type const &":
        return _freeling.VectorPredicate_front(self)

    def back(self) -> "std::vector< freeling::predicate >::value_type const &":
        return _freeling.VectorPredicate_back(self)

    def assign(self, n: 'std::vector< freeling::predicate >::size_type', x: 'predicate') -> "void":
        return _freeling.VectorPredicate_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.VectorPredicate_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.VectorPredicate_insert(self, *args)

    def reserve(self, n: 'std::vector< freeling::predicate >::size_type') -> "void":
        return _freeling.VectorPredicate_reserve(self, n)

    def capacity(self) -> "std::vector< freeling::predicate >::size_type":
        return _freeling.VectorPredicate_capacity(self)
    __swig_destroy__ = _freeling.delete_VectorPredicate
    __del__ = lambda self: None
VectorPredicate_swigregister = _freeling.VectorPredicate_swigregister
VectorPredicate_swigregister(VectorPredicate)

class VectorSGMention(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorSGMention, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorSGMention, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.VectorSGMention_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.VectorSGMention___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.VectorSGMention___bool__(self)

    def __len__(self) -> "std::vector< freeling::semgraph::SG_mention >::size_type":
        return _freeling.VectorSGMention___len__(self)

    def __getslice__(self, i: 'std::vector< freeling::semgraph::SG_mention >::difference_type', j: 'std::vector< freeling::semgraph::SG_mention >::difference_type') -> "std::vector< freeling::semgraph::SG_mention,std::allocator< freeling::semgraph::SG_mention > > *":
        return _freeling.VectorSGMention___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.VectorSGMention___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< freeling::semgraph::SG_mention >::difference_type', j: 'std::vector< freeling::semgraph::SG_mention >::difference_type') -> "void":
        return _freeling.VectorSGMention___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.VectorSGMention___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< freeling::semgraph::SG_mention >::value_type const &":
        return _freeling.VectorSGMention___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.VectorSGMention___setitem__(self, *args)

    def pop(self) -> "std::vector< freeling::semgraph::SG_mention >::value_type":
        return _freeling.VectorSGMention_pop(self)

    def append(self, x: 'SG_mention') -> "void":
        return _freeling.VectorSGMention_append(self, x)

    def empty(self) -> "bool":
        return _freeling.VectorSGMention_empty(self)

    def size(self) -> "std::vector< freeling::semgraph::SG_mention >::size_type":
        return _freeling.VectorSGMention_size(self)

    def swap(self, v: 'VectorSGMention') -> "void":
        return _freeling.VectorSGMention_swap(self, v)

    def begin(self) -> "std::vector< freeling::semgraph::SG_mention >::iterator":
        return _freeling.VectorSGMention_begin(self)

    def end(self) -> "std::vector< freeling::semgraph::SG_mention >::iterator":
        return _freeling.VectorSGMention_end(self)

    def rbegin(self) -> "std::vector< freeling::semgraph::SG_mention >::reverse_iterator":
        return _freeling.VectorSGMention_rbegin(self)

    def rend(self) -> "std::vector< freeling::semgraph::SG_mention >::reverse_iterator":
        return _freeling.VectorSGMention_rend(self)

    def clear(self) -> "void":
        return _freeling.VectorSGMention_clear(self)

    def get_allocator(self) -> "std::vector< freeling::semgraph::SG_mention >::allocator_type":
        return _freeling.VectorSGMention_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.VectorSGMention_pop_back(self)

    def erase(self, *args) -> "std::vector< freeling::semgraph::SG_mention >::iterator":
        return _freeling.VectorSGMention_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_VectorSGMention(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'SG_mention') -> "void":
        return _freeling.VectorSGMention_push_back(self, x)

    def front(self) -> "std::vector< freeling::semgraph::SG_mention >::value_type const &":
        return _freeling.VectorSGMention_front(self)

    def back(self) -> "std::vector< freeling::semgraph::SG_mention >::value_type const &":
        return _freeling.VectorSGMention_back(self)

    def assign(self, n: 'std::vector< freeling::semgraph::SG_mention >::size_type', x: 'SG_mention') -> "void":
        return _freeling.VectorSGMention_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.VectorSGMention_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.VectorSGMention_insert(self, *args)

    def reserve(self, n: 'std::vector< freeling::semgraph::SG_mention >::size_type') -> "void":
        return _freeling.VectorSGMention_reserve(self, n)

    def capacity(self) -> "std::vector< freeling::semgraph::SG_mention >::size_type":
        return _freeling.VectorSGMention_capacity(self)
    __swig_destroy__ = _freeling.delete_VectorSGMention
    __del__ = lambda self: None
VectorSGMention_swigregister = _freeling.VectorSGMention_swigregister
VectorSGMention_swigregister(VectorSGMention)

class VectorSGArgument(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorSGArgument, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorSGArgument, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.VectorSGArgument_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.VectorSGArgument___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.VectorSGArgument___bool__(self)

    def __len__(self) -> "std::vector< freeling::semgraph::SG_argument >::size_type":
        return _freeling.VectorSGArgument___len__(self)

    def __getslice__(self, i: 'std::vector< freeling::semgraph::SG_argument >::difference_type', j: 'std::vector< freeling::semgraph::SG_argument >::difference_type') -> "std::vector< freeling::semgraph::SG_argument,std::allocator< freeling::semgraph::SG_argument > > *":
        return _freeling.VectorSGArgument___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.VectorSGArgument___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< freeling::semgraph::SG_argument >::difference_type', j: 'std::vector< freeling::semgraph::SG_argument >::difference_type') -> "void":
        return _freeling.VectorSGArgument___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.VectorSGArgument___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< freeling::semgraph::SG_argument >::value_type const &":
        return _freeling.VectorSGArgument___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.VectorSGArgument___setitem__(self, *args)

    def pop(self) -> "std::vector< freeling::semgraph::SG_argument >::value_type":
        return _freeling.VectorSGArgument_pop(self)

    def append(self, x: 'SG_argument') -> "void":
        return _freeling.VectorSGArgument_append(self, x)

    def empty(self) -> "bool":
        return _freeling.VectorSGArgument_empty(self)

    def size(self) -> "std::vector< freeling::semgraph::SG_argument >::size_type":
        return _freeling.VectorSGArgument_size(self)

    def swap(self, v: 'VectorSGArgument') -> "void":
        return _freeling.VectorSGArgument_swap(self, v)

    def begin(self) -> "std::vector< freeling::semgraph::SG_argument >::iterator":
        return _freeling.VectorSGArgument_begin(self)

    def end(self) -> "std::vector< freeling::semgraph::SG_argument >::iterator":
        return _freeling.VectorSGArgument_end(self)

    def rbegin(self) -> "std::vector< freeling::semgraph::SG_argument >::reverse_iterator":
        return _freeling.VectorSGArgument_rbegin(self)

    def rend(self) -> "std::vector< freeling::semgraph::SG_argument >::reverse_iterator":
        return _freeling.VectorSGArgument_rend(self)

    def clear(self) -> "void":
        return _freeling.VectorSGArgument_clear(self)

    def get_allocator(self) -> "std::vector< freeling::semgraph::SG_argument >::allocator_type":
        return _freeling.VectorSGArgument_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.VectorSGArgument_pop_back(self)

    def erase(self, *args) -> "std::vector< freeling::semgraph::SG_argument >::iterator":
        return _freeling.VectorSGArgument_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_VectorSGArgument(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'SG_argument') -> "void":
        return _freeling.VectorSGArgument_push_back(self, x)

    def front(self) -> "std::vector< freeling::semgraph::SG_argument >::value_type const &":
        return _freeling.VectorSGArgument_front(self)

    def back(self) -> "std::vector< freeling::semgraph::SG_argument >::value_type const &":
        return _freeling.VectorSGArgument_back(self)

    def assign(self, n: 'std::vector< freeling::semgraph::SG_argument >::size_type', x: 'SG_argument') -> "void":
        return _freeling.VectorSGArgument_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.VectorSGArgument_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.VectorSGArgument_insert(self, *args)

    def reserve(self, n: 'std::vector< freeling::semgraph::SG_argument >::size_type') -> "void":
        return _freeling.VectorSGArgument_reserve(self, n)

    def capacity(self) -> "std::vector< freeling::semgraph::SG_argument >::size_type":
        return _freeling.VectorSGArgument_capacity(self)
    __swig_destroy__ = _freeling.delete_VectorSGArgument
    __del__ = lambda self: None
VectorSGArgument_swigregister = _freeling.VectorSGArgument_swigregister
VectorSGArgument_swigregister(VectorSGArgument)

class VectorSGEntity(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorSGEntity, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorSGEntity, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.VectorSGEntity_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.VectorSGEntity___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.VectorSGEntity___bool__(self)

    def __len__(self) -> "std::vector< freeling::semgraph::SG_entity >::size_type":
        return _freeling.VectorSGEntity___len__(self)

    def __getslice__(self, i: 'std::vector< freeling::semgraph::SG_entity >::difference_type', j: 'std::vector< freeling::semgraph::SG_entity >::difference_type') -> "std::vector< freeling::semgraph::SG_entity,std::allocator< freeling::semgraph::SG_entity > > *":
        return _freeling.VectorSGEntity___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.VectorSGEntity___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< freeling::semgraph::SG_entity >::difference_type', j: 'std::vector< freeling::semgraph::SG_entity >::difference_type') -> "void":
        return _freeling.VectorSGEntity___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.VectorSGEntity___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< freeling::semgraph::SG_entity >::value_type const &":
        return _freeling.VectorSGEntity___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.VectorSGEntity___setitem__(self, *args)

    def pop(self) -> "std::vector< freeling::semgraph::SG_entity >::value_type":
        return _freeling.VectorSGEntity_pop(self)

    def append(self, x: 'SG_entity') -> "void":
        return _freeling.VectorSGEntity_append(self, x)

    def empty(self) -> "bool":
        return _freeling.VectorSGEntity_empty(self)

    def size(self) -> "std::vector< freeling::semgraph::SG_entity >::size_type":
        return _freeling.VectorSGEntity_size(self)

    def swap(self, v: 'VectorSGEntity') -> "void":
        return _freeling.VectorSGEntity_swap(self, v)

    def begin(self) -> "std::vector< freeling::semgraph::SG_entity >::iterator":
        return _freeling.VectorSGEntity_begin(self)

    def end(self) -> "std::vector< freeling::semgraph::SG_entity >::iterator":
        return _freeling.VectorSGEntity_end(self)

    def rbegin(self) -> "std::vector< freeling::semgraph::SG_entity >::reverse_iterator":
        return _freeling.VectorSGEntity_rbegin(self)

    def rend(self) -> "std::vector< freeling::semgraph::SG_entity >::reverse_iterator":
        return _freeling.VectorSGEntity_rend(self)

    def clear(self) -> "void":
        return _freeling.VectorSGEntity_clear(self)

    def get_allocator(self) -> "std::vector< freeling::semgraph::SG_entity >::allocator_type":
        return _freeling.VectorSGEntity_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.VectorSGEntity_pop_back(self)

    def erase(self, *args) -> "std::vector< freeling::semgraph::SG_entity >::iterator":
        return _freeling.VectorSGEntity_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_VectorSGEntity(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'SG_entity') -> "void":
        return _freeling.VectorSGEntity_push_back(self, x)

    def front(self) -> "std::vector< freeling::semgraph::SG_entity >::value_type const &":
        return _freeling.VectorSGEntity_front(self)

    def back(self) -> "std::vector< freeling::semgraph::SG_entity >::value_type const &":
        return _freeling.VectorSGEntity_back(self)

    def assign(self, n: 'std::vector< freeling::semgraph::SG_entity >::size_type', x: 'SG_entity') -> "void":
        return _freeling.VectorSGEntity_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.VectorSGEntity_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.VectorSGEntity_insert(self, *args)

    def reserve(self, n: 'std::vector< freeling::semgraph::SG_entity >::size_type') -> "void":
        return _freeling.VectorSGEntity_reserve(self, n)

    def capacity(self) -> "std::vector< freeling::semgraph::SG_entity >::size_type":
        return _freeling.VectorSGEntity_capacity(self)
    __swig_destroy__ = _freeling.delete_VectorSGEntity
    __del__ = lambda self: None
VectorSGEntity_swigregister = _freeling.VectorSGEntity_swigregister
VectorSGEntity_swigregister(VectorSGEntity)

class VectorSGFrame(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorSGFrame, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorSGFrame, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.VectorSGFrame_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.VectorSGFrame___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.VectorSGFrame___bool__(self)

    def __len__(self) -> "std::vector< freeling::semgraph::SG_frame >::size_type":
        return _freeling.VectorSGFrame___len__(self)

    def __getslice__(self, i: 'std::vector< freeling::semgraph::SG_frame >::difference_type', j: 'std::vector< freeling::semgraph::SG_frame >::difference_type') -> "std::vector< freeling::semgraph::SG_frame,std::allocator< freeling::semgraph::SG_frame > > *":
        return _freeling.VectorSGFrame___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.VectorSGFrame___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< freeling::semgraph::SG_frame >::difference_type', j: 'std::vector< freeling::semgraph::SG_frame >::difference_type') -> "void":
        return _freeling.VectorSGFrame___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.VectorSGFrame___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< freeling::semgraph::SG_frame >::value_type const &":
        return _freeling.VectorSGFrame___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.VectorSGFrame___setitem__(self, *args)

    def pop(self) -> "std::vector< freeling::semgraph::SG_frame >::value_type":
        return _freeling.VectorSGFrame_pop(self)

    def append(self, x: 'SG_frame') -> "void":
        return _freeling.VectorSGFrame_append(self, x)

    def empty(self) -> "bool":
        return _freeling.VectorSGFrame_empty(self)

    def size(self) -> "std::vector< freeling::semgraph::SG_frame >::size_type":
        return _freeling.VectorSGFrame_size(self)

    def swap(self, v: 'VectorSGFrame') -> "void":
        return _freeling.VectorSGFrame_swap(self, v)

    def begin(self) -> "std::vector< freeling::semgraph::SG_frame >::iterator":
        return _freeling.VectorSGFrame_begin(self)

    def end(self) -> "std::vector< freeling::semgraph::SG_frame >::iterator":
        return _freeling.VectorSGFrame_end(self)

    def rbegin(self) -> "std::vector< freeling::semgraph::SG_frame >::reverse_iterator":
        return _freeling.VectorSGFrame_rbegin(self)

    def rend(self) -> "std::vector< freeling::semgraph::SG_frame >::reverse_iterator":
        return _freeling.VectorSGFrame_rend(self)

    def clear(self) -> "void":
        return _freeling.VectorSGFrame_clear(self)

    def get_allocator(self) -> "std::vector< freeling::semgraph::SG_frame >::allocator_type":
        return _freeling.VectorSGFrame_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.VectorSGFrame_pop_back(self)

    def erase(self, *args) -> "std::vector< freeling::semgraph::SG_frame >::iterator":
        return _freeling.VectorSGFrame_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_VectorSGFrame(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'SG_frame') -> "void":
        return _freeling.VectorSGFrame_push_back(self, x)

    def front(self) -> "std::vector< freeling::semgraph::SG_frame >::value_type const &":
        return _freeling.VectorSGFrame_front(self)

    def back(self) -> "std::vector< freeling::semgraph::SG_frame >::value_type const &":
        return _freeling.VectorSGFrame_back(self)

    def assign(self, n: 'std::vector< freeling::semgraph::SG_frame >::size_type', x: 'SG_frame') -> "void":
        return _freeling.VectorSGFrame_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.VectorSGFrame_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.VectorSGFrame_insert(self, *args)

    def reserve(self, n: 'std::vector< freeling::semgraph::SG_frame >::size_type') -> "void":
        return _freeling.VectorSGFrame_reserve(self, n)

    def capacity(self) -> "std::vector< freeling::semgraph::SG_frame >::size_type":
        return _freeling.VectorSGFrame_capacity(self)
    __swig_destroy__ = _freeling.delete_VectorSGFrame
    __del__ = lambda self: None
VectorSGFrame_swigregister = _freeling.VectorSGFrame_swigregister
VectorSGFrame_swigregister(VectorSGFrame)

class ListString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ListString, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.ListString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.ListString___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.ListString___bool__(self)

    def __len__(self) -> "std::list< std::wstring >::size_type":
        return _freeling.ListString___len__(self)

    def __getslice__(self, i: 'std::list< std::wstring >::difference_type', j: 'std::list< std::wstring >::difference_type') -> "std::list< std::wstring,std::allocator< std::wstring > > *":
        return _freeling.ListString___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.ListString___setslice__(self, *args)

    def __delslice__(self, i: 'std::list< std::wstring >::difference_type', j: 'std::list< std::wstring >::difference_type') -> "void":
        return _freeling.ListString___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.ListString___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< std::wstring >::value_type const &":
        return _freeling.ListString___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.ListString___setitem__(self, *args)

    def pop(self) -> "std::list< std::wstring >::value_type":
        return _freeling.ListString_pop(self)

    def append(self, x: 'std::list< std::wstring >::value_type const &') -> "void":
        return _freeling.ListString_append(self, x)

    def empty(self) -> "bool":
        return _freeling.ListString_empty(self)

    def size(self) -> "std::list< std::wstring >::size_type":
        return _freeling.ListString_size(self)

    def swap(self, v: 'ListString') -> "void":
        return _freeling.ListString_swap(self, v)

    def begin(self) -> "std::list< std::wstring >::iterator":
        return _freeling.ListString_begin(self)

    def end(self) -> "std::list< std::wstring >::iterator":
        return _freeling.ListString_end(self)

    def rbegin(self) -> "std::list< std::wstring >::reverse_iterator":
        return _freeling.ListString_rbegin(self)

    def rend(self) -> "std::list< std::wstring >::reverse_iterator":
        return _freeling.ListString_rend(self)

    def clear(self) -> "void":
        return _freeling.ListString_clear(self)

    def get_allocator(self) -> "std::list< std::wstring >::allocator_type":
        return _freeling.ListString_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.ListString_pop_back(self)

    def erase(self, *args) -> "std::list< std::wstring >::iterator":
        return _freeling.ListString_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_ListString(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::list< std::wstring >::value_type const &') -> "void":
        return _freeling.ListString_push_back(self, x)

    def front(self) -> "std::list< std::wstring >::value_type const &":
        return _freeling.ListString_front(self)

    def back(self) -> "std::list< std::wstring >::value_type const &":
        return _freeling.ListString_back(self)

    def assign(self, n: 'std::list< std::wstring >::size_type', x: 'std::list< std::wstring >::value_type const &') -> "void":
        return _freeling.ListString_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.ListString_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.ListString_insert(self, *args)

    def pop_front(self) -> "void":
        return _freeling.ListString_pop_front(self)

    def push_front(self, x: 'std::list< std::wstring >::value_type const &') -> "void":
        return _freeling.ListString_push_front(self, x)

    def reverse(self) -> "void":
        return _freeling.ListString_reverse(self)
    __swig_destroy__ = _freeling.delete_ListString
    __del__ = lambda self: None
ListString_swigregister = _freeling.ListString_swigregister
ListString_swigregister(ListString)

class ListInt(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ListInt, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.ListInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.ListInt___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.ListInt___bool__(self)

    def __len__(self) -> "std::list< int >::size_type":
        return _freeling.ListInt___len__(self)

    def __getslice__(self, i: 'std::list< int >::difference_type', j: 'std::list< int >::difference_type') -> "std::list< int,std::allocator< int > > *":
        return _freeling.ListInt___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.ListInt___setslice__(self, *args)

    def __delslice__(self, i: 'std::list< int >::difference_type', j: 'std::list< int >::difference_type') -> "void":
        return _freeling.ListInt___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.ListInt___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< int >::value_type const &":
        return _freeling.ListInt___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.ListInt___setitem__(self, *args)

    def pop(self) -> "std::list< int >::value_type":
        return _freeling.ListInt_pop(self)

    def append(self, x: 'std::list< int >::value_type const &') -> "void":
        return _freeling.ListInt_append(self, x)

    def empty(self) -> "bool":
        return _freeling.ListInt_empty(self)

    def size(self) -> "std::list< int >::size_type":
        return _freeling.ListInt_size(self)

    def swap(self, v: 'ListInt') -> "void":
        return _freeling.ListInt_swap(self, v)

    def begin(self) -> "std::list< int >::iterator":
        return _freeling.ListInt_begin(self)

    def end(self) -> "std::list< int >::iterator":
        return _freeling.ListInt_end(self)

    def rbegin(self) -> "std::list< int >::reverse_iterator":
        return _freeling.ListInt_rbegin(self)

    def rend(self) -> "std::list< int >::reverse_iterator":
        return _freeling.ListInt_rend(self)

    def clear(self) -> "void":
        return _freeling.ListInt_clear(self)

    def get_allocator(self) -> "std::list< int >::allocator_type":
        return _freeling.ListInt_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.ListInt_pop_back(self)

    def erase(self, *args) -> "std::list< int >::iterator":
        return _freeling.ListInt_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_ListInt(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::list< int >::value_type const &') -> "void":
        return _freeling.ListInt_push_back(self, x)

    def front(self) -> "std::list< int >::value_type const &":
        return _freeling.ListInt_front(self)

    def back(self) -> "std::list< int >::value_type const &":
        return _freeling.ListInt_back(self)

    def assign(self, n: 'std::list< int >::size_type', x: 'std::list< int >::value_type const &') -> "void":
        return _freeling.ListInt_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.ListInt_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.ListInt_insert(self, *args)

    def pop_front(self) -> "void":
        return _freeling.ListInt_pop_front(self)

    def push_front(self, x: 'std::list< int >::value_type const &') -> "void":
        return _freeling.ListInt_push_front(self, x)

    def reverse(self) -> "void":
        return _freeling.ListInt_reverse(self)
    __swig_destroy__ = _freeling.delete_ListInt
    __del__ = lambda self: None
ListInt_swigregister = _freeling.ListInt_swigregister
ListInt_swigregister(ListInt)

class VectorListInt(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorListInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorListInt, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.VectorListInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.VectorListInt___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.VectorListInt___bool__(self)

    def __len__(self) -> "std::vector< std::list< int > >::size_type":
        return _freeling.VectorListInt___len__(self)

    def __getslice__(self, i: 'std::vector< std::list< int > >::difference_type', j: 'std::vector< std::list< int > >::difference_type') -> "std::vector< std::list< int,std::allocator< int > >,std::allocator< std::list< int,std::allocator< int > > > > *":
        return _freeling.VectorListInt___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.VectorListInt___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::list< int > >::difference_type', j: 'std::vector< std::list< int > >::difference_type') -> "void":
        return _freeling.VectorListInt___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.VectorListInt___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::list< int > >::value_type const &":
        return _freeling.VectorListInt___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.VectorListInt___setitem__(self, *args)

    def pop(self) -> "std::vector< std::list< int > >::value_type":
        return _freeling.VectorListInt_pop(self)

    def append(self, x: 'ListInt') -> "void":
        return _freeling.VectorListInt_append(self, x)

    def empty(self) -> "bool":
        return _freeling.VectorListInt_empty(self)

    def size(self) -> "std::vector< std::list< int > >::size_type":
        return _freeling.VectorListInt_size(self)

    def swap(self, v: 'VectorListInt') -> "void":
        return _freeling.VectorListInt_swap(self, v)

    def begin(self) -> "std::vector< std::list< int > >::iterator":
        return _freeling.VectorListInt_begin(self)

    def end(self) -> "std::vector< std::list< int > >::iterator":
        return _freeling.VectorListInt_end(self)

    def rbegin(self) -> "std::vector< std::list< int > >::reverse_iterator":
        return _freeling.VectorListInt_rbegin(self)

    def rend(self) -> "std::vector< std::list< int > >::reverse_iterator":
        return _freeling.VectorListInt_rend(self)

    def clear(self) -> "void":
        return _freeling.VectorListInt_clear(self)

    def get_allocator(self) -> "std::vector< std::list< int > >::allocator_type":
        return _freeling.VectorListInt_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.VectorListInt_pop_back(self)

    def erase(self, *args) -> "std::vector< std::list< int > >::iterator":
        return _freeling.VectorListInt_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_VectorListInt(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'ListInt') -> "void":
        return _freeling.VectorListInt_push_back(self, x)

    def front(self) -> "std::vector< std::list< int > >::value_type const &":
        return _freeling.VectorListInt_front(self)

    def back(self) -> "std::vector< std::list< int > >::value_type const &":
        return _freeling.VectorListInt_back(self)

    def assign(self, n: 'std::vector< std::list< int > >::size_type', x: 'ListInt') -> "void":
        return _freeling.VectorListInt_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.VectorListInt_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.VectorListInt_insert(self, *args)

    def reserve(self, n: 'std::vector< std::list< int > >::size_type') -> "void":
        return _freeling.VectorListInt_reserve(self, n)

    def capacity(self) -> "std::vector< std::list< int > >::size_type":
        return _freeling.VectorListInt_capacity(self)
    __swig_destroy__ = _freeling.delete_VectorListInt
    __del__ = lambda self: None
VectorListInt_swigregister = _freeling.VectorListInt_swigregister
VectorListInt_swigregister(VectorListInt)

class VectorListString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorListString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorListString, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.VectorListString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.VectorListString___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.VectorListString___bool__(self)

    def __len__(self) -> "std::vector< std::list< std::wstring > >::size_type":
        return _freeling.VectorListString___len__(self)

    def __getslice__(self, i: 'std::vector< std::list< std::wstring > >::difference_type', j: 'std::vector< std::list< std::wstring > >::difference_type') -> "std::vector< std::list< std::wstring,std::allocator< std::wstring > >,std::allocator< std::list< std::wstring,std::allocator< std::wstring > > > > *":
        return _freeling.VectorListString___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.VectorListString___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::list< std::wstring > >::difference_type', j: 'std::vector< std::list< std::wstring > >::difference_type') -> "void":
        return _freeling.VectorListString___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.VectorListString___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::list< std::wstring > >::value_type const &":
        return _freeling.VectorListString___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.VectorListString___setitem__(self, *args)

    def pop(self) -> "std::vector< std::list< std::wstring > >::value_type":
        return _freeling.VectorListString_pop(self)

    def append(self, x: 'ListString') -> "void":
        return _freeling.VectorListString_append(self, x)

    def empty(self) -> "bool":
        return _freeling.VectorListString_empty(self)

    def size(self) -> "std::vector< std::list< std::wstring > >::size_type":
        return _freeling.VectorListString_size(self)

    def swap(self, v: 'VectorListString') -> "void":
        return _freeling.VectorListString_swap(self, v)

    def begin(self) -> "std::vector< std::list< std::wstring > >::iterator":
        return _freeling.VectorListString_begin(self)

    def end(self) -> "std::vector< std::list< std::wstring > >::iterator":
        return _freeling.VectorListString_end(self)

    def rbegin(self) -> "std::vector< std::list< std::wstring > >::reverse_iterator":
        return _freeling.VectorListString_rbegin(self)

    def rend(self) -> "std::vector< std::list< std::wstring > >::reverse_iterator":
        return _freeling.VectorListString_rend(self)

    def clear(self) -> "void":
        return _freeling.VectorListString_clear(self)

    def get_allocator(self) -> "std::vector< std::list< std::wstring > >::allocator_type":
        return _freeling.VectorListString_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.VectorListString_pop_back(self)

    def erase(self, *args) -> "std::vector< std::list< std::wstring > >::iterator":
        return _freeling.VectorListString_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_VectorListString(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'ListString') -> "void":
        return _freeling.VectorListString_push_back(self, x)

    def front(self) -> "std::vector< std::list< std::wstring > >::value_type const &":
        return _freeling.VectorListString_front(self)

    def back(self) -> "std::vector< std::list< std::wstring > >::value_type const &":
        return _freeling.VectorListString_back(self)

    def assign(self, n: 'std::vector< std::list< std::wstring > >::size_type', x: 'ListString') -> "void":
        return _freeling.VectorListString_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.VectorListString_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.VectorListString_insert(self, *args)

    def reserve(self, n: 'std::vector< std::list< std::wstring > >::size_type') -> "void":
        return _freeling.VectorListString_reserve(self, n)

    def capacity(self) -> "std::vector< std::list< std::wstring > >::size_type":
        return _freeling.VectorListString_capacity(self)
    __swig_destroy__ = _freeling.delete_VectorListString
    __del__ = lambda self: None
VectorListString_swigregister = _freeling.VectorListString_swigregister
VectorListString_swigregister(VectorListString)

class VectorString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorString, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.VectorString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.VectorString___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.VectorString___bool__(self)

    def __len__(self) -> "std::vector< std::wstring >::size_type":
        return _freeling.VectorString___len__(self)

    def __getslice__(self, i: 'std::vector< std::wstring >::difference_type', j: 'std::vector< std::wstring >::difference_type') -> "std::vector< std::wstring,std::allocator< std::wstring > > *":
        return _freeling.VectorString___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.VectorString___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::wstring >::difference_type', j: 'std::vector< std::wstring >::difference_type') -> "void":
        return _freeling.VectorString___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.VectorString___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::wstring >::value_type const &":
        return _freeling.VectorString___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.VectorString___setitem__(self, *args)

    def pop(self) -> "std::vector< std::wstring >::value_type":
        return _freeling.VectorString_pop(self)

    def append(self, x: 'std::vector< std::wstring >::value_type const &') -> "void":
        return _freeling.VectorString_append(self, x)

    def empty(self) -> "bool":
        return _freeling.VectorString_empty(self)

    def size(self) -> "std::vector< std::wstring >::size_type":
        return _freeling.VectorString_size(self)

    def swap(self, v: 'VectorString') -> "void":
        return _freeling.VectorString_swap(self, v)

    def begin(self) -> "std::vector< std::wstring >::iterator":
        return _freeling.VectorString_begin(self)

    def end(self) -> "std::vector< std::wstring >::iterator":
        return _freeling.VectorString_end(self)

    def rbegin(self) -> "std::vector< std::wstring >::reverse_iterator":
        return _freeling.VectorString_rbegin(self)

    def rend(self) -> "std::vector< std::wstring >::reverse_iterator":
        return _freeling.VectorString_rend(self)

    def clear(self) -> "void":
        return _freeling.VectorString_clear(self)

    def get_allocator(self) -> "std::vector< std::wstring >::allocator_type":
        return _freeling.VectorString_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.VectorString_pop_back(self)

    def erase(self, *args) -> "std::vector< std::wstring >::iterator":
        return _freeling.VectorString_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_VectorString(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< std::wstring >::value_type const &') -> "void":
        return _freeling.VectorString_push_back(self, x)

    def front(self) -> "std::vector< std::wstring >::value_type const &":
        return _freeling.VectorString_front(self)

    def back(self) -> "std::vector< std::wstring >::value_type const &":
        return _freeling.VectorString_back(self)

    def assign(self, n: 'std::vector< std::wstring >::size_type', x: 'std::vector< std::wstring >::value_type const &') -> "void":
        return _freeling.VectorString_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.VectorString_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.VectorString_insert(self, *args)

    def reserve(self, n: 'std::vector< std::wstring >::size_type') -> "void":
        return _freeling.VectorString_reserve(self, n)

    def capacity(self) -> "std::vector< std::wstring >::size_type":
        return _freeling.VectorString_capacity(self)
    __swig_destroy__ = _freeling.delete_VectorString
    __del__ = lambda self: None
VectorString_swigregister = _freeling.VectorString_swigregister
VectorString_swigregister(VectorString)

class VectorSetString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorSetString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorSetString, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.VectorSetString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.VectorSetString___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.VectorSetString___bool__(self)

    def __len__(self) -> "std::vector< std::set< std::wstring > >::size_type":
        return _freeling.VectorSetString___len__(self)

    def __getslice__(self, i: 'std::vector< std::set< std::wstring > >::difference_type', j: 'std::vector< std::set< std::wstring > >::difference_type') -> "std::vector< std::set< std::wstring,std::less< std::wstring >,std::allocator< std::wstring > >,std::allocator< std::set< std::wstring,std::less< std::wstring >,std::allocator< std::wstring > > > > *":
        return _freeling.VectorSetString___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.VectorSetString___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::set< std::wstring > >::difference_type', j: 'std::vector< std::set< std::wstring > >::difference_type') -> "void":
        return _freeling.VectorSetString___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.VectorSetString___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::set< std::wstring > >::value_type const &":
        return _freeling.VectorSetString___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.VectorSetString___setitem__(self, *args)

    def pop(self) -> "std::vector< std::set< std::wstring > >::value_type":
        return _freeling.VectorSetString_pop(self)

    def append(self, x: 'SetString') -> "void":
        return _freeling.VectorSetString_append(self, x)

    def empty(self) -> "bool":
        return _freeling.VectorSetString_empty(self)

    def size(self) -> "std::vector< std::set< std::wstring > >::size_type":
        return _freeling.VectorSetString_size(self)

    def swap(self, v: 'VectorSetString') -> "void":
        return _freeling.VectorSetString_swap(self, v)

    def begin(self) -> "std::vector< std::set< std::wstring > >::iterator":
        return _freeling.VectorSetString_begin(self)

    def end(self) -> "std::vector< std::set< std::wstring > >::iterator":
        return _freeling.VectorSetString_end(self)

    def rbegin(self) -> "std::vector< std::set< std::wstring > >::reverse_iterator":
        return _freeling.VectorSetString_rbegin(self)

    def rend(self) -> "std::vector< std::set< std::wstring > >::reverse_iterator":
        return _freeling.VectorSetString_rend(self)

    def clear(self) -> "void":
        return _freeling.VectorSetString_clear(self)

    def get_allocator(self) -> "std::vector< std::set< std::wstring > >::allocator_type":
        return _freeling.VectorSetString_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.VectorSetString_pop_back(self)

    def erase(self, *args) -> "std::vector< std::set< std::wstring > >::iterator":
        return _freeling.VectorSetString_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_VectorSetString(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'SetString') -> "void":
        return _freeling.VectorSetString_push_back(self, x)

    def front(self) -> "std::vector< std::set< std::wstring > >::value_type const &":
        return _freeling.VectorSetString_front(self)

    def back(self) -> "std::vector< std::set< std::wstring > >::value_type const &":
        return _freeling.VectorSetString_back(self)

    def assign(self, n: 'std::vector< std::set< std::wstring > >::size_type', x: 'SetString') -> "void":
        return _freeling.VectorSetString_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.VectorSetString_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.VectorSetString_insert(self, *args)

    def reserve(self, n: 'std::vector< std::set< std::wstring > >::size_type') -> "void":
        return _freeling.VectorSetString_reserve(self, n)

    def capacity(self) -> "std::vector< std::set< std::wstring > >::size_type":
        return _freeling.VectorSetString_capacity(self)
    __swig_destroy__ = _freeling.delete_VectorSetString
    __del__ = lambda self: None
VectorSetString_swigregister = _freeling.VectorSetString_swigregister
VectorSetString_swigregister(VectorSetString)

class VectorSetInt(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorSetInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorSetInt, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.VectorSetInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.VectorSetInt___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.VectorSetInt___bool__(self)

    def __len__(self) -> "std::vector< std::set< int > >::size_type":
        return _freeling.VectorSetInt___len__(self)

    def __getslice__(self, i: 'std::vector< std::set< int > >::difference_type', j: 'std::vector< std::set< int > >::difference_type') -> "std::vector< std::set< int,std::less< int >,std::allocator< int > >,std::allocator< std::set< int,std::less< int >,std::allocator< int > > > > *":
        return _freeling.VectorSetInt___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.VectorSetInt___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::set< int > >::difference_type', j: 'std::vector< std::set< int > >::difference_type') -> "void":
        return _freeling.VectorSetInt___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.VectorSetInt___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::set< int > >::value_type const &":
        return _freeling.VectorSetInt___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.VectorSetInt___setitem__(self, *args)

    def pop(self) -> "std::vector< std::set< int > >::value_type":
        return _freeling.VectorSetInt_pop(self)

    def append(self, x: 'std::vector< std::set< int > >::value_type const &') -> "void":
        return _freeling.VectorSetInt_append(self, x)

    def empty(self) -> "bool":
        return _freeling.VectorSetInt_empty(self)

    def size(self) -> "std::vector< std::set< int > >::size_type":
        return _freeling.VectorSetInt_size(self)

    def swap(self, v: 'VectorSetInt') -> "void":
        return _freeling.VectorSetInt_swap(self, v)

    def begin(self) -> "std::vector< std::set< int > >::iterator":
        return _freeling.VectorSetInt_begin(self)

    def end(self) -> "std::vector< std::set< int > >::iterator":
        return _freeling.VectorSetInt_end(self)

    def rbegin(self) -> "std::vector< std::set< int > >::reverse_iterator":
        return _freeling.VectorSetInt_rbegin(self)

    def rend(self) -> "std::vector< std::set< int > >::reverse_iterator":
        return _freeling.VectorSetInt_rend(self)

    def clear(self) -> "void":
        return _freeling.VectorSetInt_clear(self)

    def get_allocator(self) -> "std::vector< std::set< int > >::allocator_type":
        return _freeling.VectorSetInt_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.VectorSetInt_pop_back(self)

    def erase(self, *args) -> "std::vector< std::set< int > >::iterator":
        return _freeling.VectorSetInt_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_VectorSetInt(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< std::set< int > >::value_type const &') -> "void":
        return _freeling.VectorSetInt_push_back(self, x)

    def front(self) -> "std::vector< std::set< int > >::value_type const &":
        return _freeling.VectorSetInt_front(self)

    def back(self) -> "std::vector< std::set< int > >::value_type const &":
        return _freeling.VectorSetInt_back(self)

    def assign(self, n: 'std::vector< std::set< int > >::size_type', x: 'std::vector< std::set< int > >::value_type const &') -> "void":
        return _freeling.VectorSetInt_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.VectorSetInt_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.VectorSetInt_insert(self, *args)

    def reserve(self, n: 'std::vector< std::set< int > >::size_type') -> "void":
        return _freeling.VectorSetInt_reserve(self, n)

    def capacity(self) -> "std::vector< std::set< int > >::size_type":
        return _freeling.VectorSetInt_capacity(self)
    __swig_destroy__ = _freeling.delete_VectorSetInt
    __del__ = lambda self: None
VectorSetInt_swigregister = _freeling.VectorSetInt_swigregister
VectorSetInt_swigregister(VectorSetInt)

class SetString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SetString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SetString, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.SetString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.SetString___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.SetString___bool__(self)

    def __len__(self) -> "std::set< std::wstring >::size_type":
        return _freeling.SetString___len__(self)

    def append(self, x: 'std::set< std::wstring >::value_type') -> "void":
        return _freeling.SetString_append(self, x)

    def __contains__(self, x: 'std::set< std::wstring >::value_type') -> "bool":
        return _freeling.SetString___contains__(self, x)

    def __getitem__(self, i: 'std::set< std::wstring >::difference_type') -> "std::set< std::wstring >::value_type":
        return _freeling.SetString___getitem__(self, i)

    def add(self, x: 'std::set< std::wstring >::value_type') -> "void":
        return _freeling.SetString_add(self, x)

    def discard(self, x: 'std::set< std::wstring >::value_type') -> "void":
        return _freeling.SetString_discard(self, x)

    def __init__(self, *args):
        this = _freeling.new_SetString(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self) -> "bool":
        return _freeling.SetString_empty(self)

    def size(self) -> "std::set< std::wstring >::size_type":
        return _freeling.SetString_size(self)

    def clear(self) -> "void":
        return _freeling.SetString_clear(self)

    def swap(self, v: 'SetString') -> "void":
        return _freeling.SetString_swap(self, v)

    def count(self, x: 'std::set< std::wstring >::key_type const &') -> "std::set< std::wstring >::size_type":
        return _freeling.SetString_count(self, x)

    def begin(self) -> "std::set< std::wstring >::iterator":
        return _freeling.SetString_begin(self)

    def end(self) -> "std::set< std::wstring >::iterator":
        return _freeling.SetString_end(self)

    def rbegin(self) -> "std::set< std::wstring >::reverse_iterator":
        return _freeling.SetString_rbegin(self)

    def rend(self) -> "std::set< std::wstring >::reverse_iterator":
        return _freeling.SetString_rend(self)

    def erase(self, *args) -> "void":
        return _freeling.SetString_erase(self, *args)

    def find(self, x: 'std::set< std::wstring >::key_type const &') -> "std::set< std::wstring >::iterator":
        return _freeling.SetString_find(self, x)

    def lower_bound(self, x: 'std::set< std::wstring >::key_type const &') -> "std::set< std::wstring >::iterator":
        return _freeling.SetString_lower_bound(self, x)

    def upper_bound(self, x: 'std::set< std::wstring >::key_type const &') -> "std::set< std::wstring >::iterator":
        return _freeling.SetString_upper_bound(self, x)

    def equal_range(self, x: 'std::set< std::wstring >::key_type const &') -> "std::pair< std::set< std::wstring >::iterator,std::set< std::wstring >::iterator >":
        return _freeling.SetString_equal_range(self, x)

    def insert(self, __x: 'std::set< std::wstring >::value_type const &') -> "std::pair< std::set< std::wstring >::iterator,bool >":
        return _freeling.SetString_insert(self, __x)
    __swig_destroy__ = _freeling.delete_SetString
    __del__ = lambda self: None
SetString_swigregister = _freeling.SetString_swigregister
SetString_swigregister(SetString)

class PairDoubleString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PairDoubleString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PairDoubleString, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_PairDoubleString(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _freeling.PairDoubleString_first_set
    __swig_getmethods__["first"] = _freeling.PairDoubleString_first_get
    if _newclass:
        first = _swig_property(_freeling.PairDoubleString_first_get, _freeling.PairDoubleString_first_set)
    __swig_setmethods__["second"] = _freeling.PairDoubleString_second_set
    __swig_getmethods__["second"] = _freeling.PairDoubleString_second_get
    if _newclass:
        second = _swig_property(_freeling.PairDoubleString_second_get, _freeling.PairDoubleString_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _freeling.delete_PairDoubleString
    __del__ = lambda self: None
PairDoubleString_swigregister = _freeling.PairDoubleString_swigregister
PairDoubleString_swigregister(PairDoubleString)

class VectorPairDoubleString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorPairDoubleString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorPairDoubleString, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.VectorPairDoubleString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.VectorPairDoubleString___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.VectorPairDoubleString___bool__(self)

    def __len__(self) -> "std::vector< std::pair< double,std::wstring > >::size_type":
        return _freeling.VectorPairDoubleString___len__(self)

    def __getslice__(self, i: 'std::vector< std::pair< double,std::wstring > >::difference_type', j: 'std::vector< std::pair< double,std::wstring > >::difference_type') -> "std::vector< std::pair< double,std::wstring >,std::allocator< std::pair< double,std::wstring > > > *":
        return _freeling.VectorPairDoubleString___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.VectorPairDoubleString___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::pair< double,std::wstring > >::difference_type', j: 'std::vector< std::pair< double,std::wstring > >::difference_type') -> "void":
        return _freeling.VectorPairDoubleString___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.VectorPairDoubleString___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::pair< double,std::wstring > >::value_type const &":
        return _freeling.VectorPairDoubleString___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.VectorPairDoubleString___setitem__(self, *args)

    def pop(self) -> "std::vector< std::pair< double,std::wstring > >::value_type":
        return _freeling.VectorPairDoubleString_pop(self)

    def append(self, x: 'PairDoubleString') -> "void":
        return _freeling.VectorPairDoubleString_append(self, x)

    def empty(self) -> "bool":
        return _freeling.VectorPairDoubleString_empty(self)

    def size(self) -> "std::vector< std::pair< double,std::wstring > >::size_type":
        return _freeling.VectorPairDoubleString_size(self)

    def swap(self, v: 'VectorPairDoubleString') -> "void":
        return _freeling.VectorPairDoubleString_swap(self, v)

    def begin(self) -> "std::vector< std::pair< double,std::wstring > >::iterator":
        return _freeling.VectorPairDoubleString_begin(self)

    def end(self) -> "std::vector< std::pair< double,std::wstring > >::iterator":
        return _freeling.VectorPairDoubleString_end(self)

    def rbegin(self) -> "std::vector< std::pair< double,std::wstring > >::reverse_iterator":
        return _freeling.VectorPairDoubleString_rbegin(self)

    def rend(self) -> "std::vector< std::pair< double,std::wstring > >::reverse_iterator":
        return _freeling.VectorPairDoubleString_rend(self)

    def clear(self) -> "void":
        return _freeling.VectorPairDoubleString_clear(self)

    def get_allocator(self) -> "std::vector< std::pair< double,std::wstring > >::allocator_type":
        return _freeling.VectorPairDoubleString_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.VectorPairDoubleString_pop_back(self)

    def erase(self, *args) -> "std::vector< std::pair< double,std::wstring > >::iterator":
        return _freeling.VectorPairDoubleString_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_VectorPairDoubleString(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'PairDoubleString') -> "void":
        return _freeling.VectorPairDoubleString_push_back(self, x)

    def front(self) -> "std::vector< std::pair< double,std::wstring > >::value_type const &":
        return _freeling.VectorPairDoubleString_front(self)

    def back(self) -> "std::vector< std::pair< double,std::wstring > >::value_type const &":
        return _freeling.VectorPairDoubleString_back(self)

    def assign(self, n: 'std::vector< std::pair< double,std::wstring > >::size_type', x: 'PairDoubleString') -> "void":
        return _freeling.VectorPairDoubleString_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.VectorPairDoubleString_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.VectorPairDoubleString_insert(self, *args)

    def reserve(self, n: 'std::vector< std::pair< double,std::wstring > >::size_type') -> "void":
        return _freeling.VectorPairDoubleString_reserve(self, n)

    def capacity(self) -> "std::vector< std::pair< double,std::wstring > >::size_type":
        return _freeling.VectorPairDoubleString_capacity(self)
    __swig_destroy__ = _freeling.delete_VectorPairDoubleString
    __del__ = lambda self: None
VectorPairDoubleString_swigregister = _freeling.VectorPairDoubleString_swigregister
VectorPairDoubleString_swigregister(VectorPairDoubleString)

class PairStringString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PairStringString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PairStringString, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_PairStringString(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _freeling.PairStringString_first_set
    __swig_getmethods__["first"] = _freeling.PairStringString_first_get
    if _newclass:
        first = _swig_property(_freeling.PairStringString_first_get, _freeling.PairStringString_first_set)
    __swig_setmethods__["second"] = _freeling.PairStringString_second_set
    __swig_getmethods__["second"] = _freeling.PairStringString_second_get
    if _newclass:
        second = _swig_property(_freeling.PairStringString_second_get, _freeling.PairStringString_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _freeling.delete_PairStringString
    __del__ = lambda self: None
PairStringString_swigregister = _freeling.PairStringString_swigregister
PairStringString_swigregister(PairStringString)

class VectorPairStringString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorPairStringString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorPairStringString, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.VectorPairStringString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.VectorPairStringString___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.VectorPairStringString___bool__(self)

    def __len__(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::size_type":
        return _freeling.VectorPairStringString___len__(self)

    def __getslice__(self, i: 'std::vector< std::pair< std::wstring,std::wstring > >::difference_type', j: 'std::vector< std::pair< std::wstring,std::wstring > >::difference_type') -> "std::vector< std::pair< std::wstring,std::wstring >,std::allocator< std::pair< std::wstring,std::wstring > > > *":
        return _freeling.VectorPairStringString___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.VectorPairStringString___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::pair< std::wstring,std::wstring > >::difference_type', j: 'std::vector< std::pair< std::wstring,std::wstring > >::difference_type') -> "void":
        return _freeling.VectorPairStringString___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.VectorPairStringString___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::pair< std::wstring,std::wstring > >::value_type const &":
        return _freeling.VectorPairStringString___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.VectorPairStringString___setitem__(self, *args)

    def pop(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::value_type":
        return _freeling.VectorPairStringString_pop(self)

    def append(self, x: 'PairStringString') -> "void":
        return _freeling.VectorPairStringString_append(self, x)

    def empty(self) -> "bool":
        return _freeling.VectorPairStringString_empty(self)

    def size(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::size_type":
        return _freeling.VectorPairStringString_size(self)

    def swap(self, v: 'VectorPairStringString') -> "void":
        return _freeling.VectorPairStringString_swap(self, v)

    def begin(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::iterator":
        return _freeling.VectorPairStringString_begin(self)

    def end(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::iterator":
        return _freeling.VectorPairStringString_end(self)

    def rbegin(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::reverse_iterator":
        return _freeling.VectorPairStringString_rbegin(self)

    def rend(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::reverse_iterator":
        return _freeling.VectorPairStringString_rend(self)

    def clear(self) -> "void":
        return _freeling.VectorPairStringString_clear(self)

    def get_allocator(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::allocator_type":
        return _freeling.VectorPairStringString_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.VectorPairStringString_pop_back(self)

    def erase(self, *args) -> "std::vector< std::pair< std::wstring,std::wstring > >::iterator":
        return _freeling.VectorPairStringString_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_VectorPairStringString(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'PairStringString') -> "void":
        return _freeling.VectorPairStringString_push_back(self, x)

    def front(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::value_type const &":
        return _freeling.VectorPairStringString_front(self)

    def back(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::value_type const &":
        return _freeling.VectorPairStringString_back(self)

    def assign(self, n: 'std::vector< std::pair< std::wstring,std::wstring > >::size_type', x: 'PairStringString') -> "void":
        return _freeling.VectorPairStringString_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.VectorPairStringString_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.VectorPairStringString_insert(self, *args)

    def reserve(self, n: 'std::vector< std::pair< std::wstring,std::wstring > >::size_type') -> "void":
        return _freeling.VectorPairStringString_reserve(self, n)

    def capacity(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::size_type":
        return _freeling.VectorPairStringString_capacity(self)
    __swig_destroy__ = _freeling.delete_VectorPairStringString
    __del__ = lambda self: None
VectorPairStringString_swigregister = _freeling.VectorPairStringString_swigregister
VectorPairStringString_swigregister(VectorPairStringString)

class PairStringInt(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PairStringInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PairStringInt, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_PairStringInt(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _freeling.PairStringInt_first_set
    __swig_getmethods__["first"] = _freeling.PairStringInt_first_get
    if _newclass:
        first = _swig_property(_freeling.PairStringInt_first_get, _freeling.PairStringInt_first_set)
    __swig_setmethods__["second"] = _freeling.PairStringInt_second_set
    __swig_getmethods__["second"] = _freeling.PairStringInt_second_get
    if _newclass:
        second = _swig_property(_freeling.PairStringInt_second_get, _freeling.PairStringInt_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _freeling.delete_PairStringInt
    __del__ = lambda self: None
PairStringInt_swigregister = _freeling.PairStringInt_swigregister
PairStringInt_swigregister(PairStringInt)

class PairStringDouble(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PairStringDouble, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PairStringDouble, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_PairStringDouble(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _freeling.PairStringDouble_first_set
    __swig_getmethods__["first"] = _freeling.PairStringDouble_first_get
    if _newclass:
        first = _swig_property(_freeling.PairStringDouble_first_get, _freeling.PairStringDouble_first_set)
    __swig_setmethods__["second"] = _freeling.PairStringDouble_second_set
    __swig_getmethods__["second"] = _freeling.PairStringDouble_second_get
    if _newclass:
        second = _swig_property(_freeling.PairStringDouble_second_get, _freeling.PairStringDouble_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _freeling.delete_PairStringDouble
    __del__ = lambda self: None
PairStringDouble_swigregister = _freeling.PairStringDouble_swigregister
PairStringDouble_swigregister(PairStringDouble)

class ListPairStringDouble(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListPairStringDouble, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ListPairStringDouble, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _freeling.ListPairStringDouble_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _freeling.ListPairStringDouble___nonzero__(self)

    def __bool__(self) -> "bool":
        return _freeling.ListPairStringDouble___bool__(self)

    def __len__(self) -> "std::list< std::pair< std::wstring,double > >::size_type":
        return _freeling.ListPairStringDouble___len__(self)

    def __getslice__(self, i: 'std::list< std::pair< std::wstring,double > >::difference_type', j: 'std::list< std::pair< std::wstring,double > >::difference_type') -> "std::list< std::pair< std::wstring,double >,std::allocator< std::pair< std::wstring,double > > > *":
        return _freeling.ListPairStringDouble___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _freeling.ListPairStringDouble___setslice__(self, *args)

    def __delslice__(self, i: 'std::list< std::pair< std::wstring,double > >::difference_type', j: 'std::list< std::pair< std::wstring,double > >::difference_type') -> "void":
        return _freeling.ListPairStringDouble___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _freeling.ListPairStringDouble___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< std::pair< std::wstring,double > >::value_type const &":
        return _freeling.ListPairStringDouble___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _freeling.ListPairStringDouble___setitem__(self, *args)

    def pop(self) -> "std::list< std::pair< std::wstring,double > >::value_type":
        return _freeling.ListPairStringDouble_pop(self)

    def append(self, x: 'PairStringDouble') -> "void":
        return _freeling.ListPairStringDouble_append(self, x)

    def empty(self) -> "bool":
        return _freeling.ListPairStringDouble_empty(self)

    def size(self) -> "std::list< std::pair< std::wstring,double > >::size_type":
        return _freeling.ListPairStringDouble_size(self)

    def swap(self, v: 'ListPairStringDouble') -> "void":
        return _freeling.ListPairStringDouble_swap(self, v)

    def begin(self) -> "std::list< std::pair< std::wstring,double > >::iterator":
        return _freeling.ListPairStringDouble_begin(self)

    def end(self) -> "std::list< std::pair< std::wstring,double > >::iterator":
        return _freeling.ListPairStringDouble_end(self)

    def rbegin(self) -> "std::list< std::pair< std::wstring,double > >::reverse_iterator":
        return _freeling.ListPairStringDouble_rbegin(self)

    def rend(self) -> "std::list< std::pair< std::wstring,double > >::reverse_iterator":
        return _freeling.ListPairStringDouble_rend(self)

    def clear(self) -> "void":
        return _freeling.ListPairStringDouble_clear(self)

    def get_allocator(self) -> "std::list< std::pair< std::wstring,double > >::allocator_type":
        return _freeling.ListPairStringDouble_get_allocator(self)

    def pop_back(self) -> "void":
        return _freeling.ListPairStringDouble_pop_back(self)

    def erase(self, *args) -> "std::list< std::pair< std::wstring,double > >::iterator":
        return _freeling.ListPairStringDouble_erase(self, *args)

    def __init__(self, *args):
        this = _freeling.new_ListPairStringDouble(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'PairStringDouble') -> "void":
        return _freeling.ListPairStringDouble_push_back(self, x)

    def front(self) -> "std::list< std::pair< std::wstring,double > >::value_type const &":
        return _freeling.ListPairStringDouble_front(self)

    def back(self) -> "std::list< std::pair< std::wstring,double > >::value_type const &":
        return _freeling.ListPairStringDouble_back(self)

    def assign(self, n: 'std::list< std::pair< std::wstring,double > >::size_type', x: 'PairStringDouble') -> "void":
        return _freeling.ListPairStringDouble_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _freeling.ListPairStringDouble_resize(self, *args)

    def insert(self, *args) -> "void":
        return _freeling.ListPairStringDouble_insert(self, *args)

    def pop_front(self) -> "void":
        return _freeling.ListPairStringDouble_pop_front(self)

    def push_front(self, x: 'PairStringDouble') -> "void":
        return _freeling.ListPairStringDouble_push_front(self, x)

    def reverse(self) -> "void":
        return _freeling.ListPairStringDouble_reverse(self)
    __swig_destroy__ = _freeling.delete_ListPairStringDouble
    __del__ = lambda self: None
ListPairStringDouble_swigregister = _freeling.ListPairStringDouble_swigregister
ListPairStringDouble_swigregister(ListPairStringDouble)

class TreeOfNode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeOfNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreeOfNode, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_TreeOfNode(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_TreeOfNode
    __del__ = lambda self: None

    def clear(self) -> "void":
        return _freeling.TreeOfNode_clear(self)

    def is_root(self) -> "bool":
        return _freeling.TreeOfNode_is_root(self)

    def empty(self) -> "bool":
        return _freeling.TreeOfNode_empty(self)

    def num_children(self) -> "unsigned int":
        return _freeling.TreeOfNode_num_children(self)

    def has_ancestor(self, arg2: 'TreeOfNode') -> "bool":
        return _freeling.TreeOfNode_has_ancestor(self, arg2)

    def add_child(self, t: 'TreeOfNode', last: 'bool'=True) -> "void":
        return _freeling.TreeOfNode_add_child(self, t, last)

    def hang_child(self, *args) -> "void":
        return _freeling.TreeOfNode_hang_child(self, *args)

    def nth_child(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator":
        return _freeling.TreeOfNode_nth_child(self, *args)

    def nth_child_ref(self, *args) -> "freeling::tree< freeling::node > const &":
        return _freeling.TreeOfNode_nth_child_ref(self, *args)

    def get_parent(self, *args) -> "freeling::tree< freeling::node >::const_preorder_iterator":
        return _freeling.TreeOfNode_get_parent(self, *args)

    def begin(self, *args) -> "freeling::tree< freeling::node >::const_preorder_iterator":
        return _freeling.TreeOfNode_begin(self, *args)

    def end(self, *args) -> "freeling::tree< freeling::node >::const_preorder_iterator":
        return _freeling.TreeOfNode_end(self, *args)

    def sibling_begin(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator":
        return _freeling.TreeOfNode_sibling_begin(self, *args)

    def sibling_end(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator":
        return _freeling.TreeOfNode_sibling_end(self, *args)

    def sibling_rbegin(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator":
        return _freeling.TreeOfNode_sibling_rbegin(self, *args)

    def sibling_rend(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator":
        return _freeling.TreeOfNode_sibling_rend(self, *args)
TreeOfNode_swigregister = _freeling.TreeOfNode_swigregister
TreeOfNode_swigregister(TreeOfNode)

class TreeOfDepnode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeOfDepnode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreeOfDepnode, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_TreeOfDepnode(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_TreeOfDepnode
    __del__ = lambda self: None

    def clear(self) -> "void":
        return _freeling.TreeOfDepnode_clear(self)

    def is_root(self) -> "bool":
        return _freeling.TreeOfDepnode_is_root(self)

    def empty(self) -> "bool":
        return _freeling.TreeOfDepnode_empty(self)

    def num_children(self) -> "unsigned int":
        return _freeling.TreeOfDepnode_num_children(self)

    def has_ancestor(self, arg2: 'TreeOfDepnode') -> "bool":
        return _freeling.TreeOfDepnode_has_ancestor(self, arg2)

    def add_child(self, t: 'TreeOfDepnode', last: 'bool'=True) -> "void":
        return _freeling.TreeOfDepnode_add_child(self, t, last)

    def hang_child(self, *args) -> "void":
        return _freeling.TreeOfDepnode_hang_child(self, *args)

    def nth_child(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator":
        return _freeling.TreeOfDepnode_nth_child(self, *args)

    def nth_child_ref(self, *args) -> "freeling::tree< freeling::depnode > const &":
        return _freeling.TreeOfDepnode_nth_child_ref(self, *args)

    def get_parent(self, *args) -> "freeling::tree< freeling::depnode >::const_preorder_iterator":
        return _freeling.TreeOfDepnode_get_parent(self, *args)

    def begin(self, *args) -> "freeling::tree< freeling::depnode >::const_preorder_iterator":
        return _freeling.TreeOfDepnode_begin(self, *args)

    def end(self, *args) -> "freeling::tree< freeling::depnode >::const_preorder_iterator":
        return _freeling.TreeOfDepnode_end(self, *args)

    def sibling_begin(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator":
        return _freeling.TreeOfDepnode_sibling_begin(self, *args)

    def sibling_end(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator":
        return _freeling.TreeOfDepnode_sibling_end(self, *args)

    def sibling_rbegin(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator":
        return _freeling.TreeOfDepnode_sibling_rbegin(self, *args)

    def sibling_rend(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator":
        return _freeling.TreeOfDepnode_sibling_rend(self, *args)
TreeOfDepnode_swigregister = _freeling.TreeOfDepnode_swigregister
TreeOfDepnode_swigregister(TreeOfDepnode)

class TreePreorderIteratorNode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreePreorderIteratorNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreePreorderIteratorNode, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_TreePreorderIteratorNode(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_TreePreorderIteratorNode
    __del__ = lambda self: None

    def incr(self) -> "void":
        return _freeling.TreePreorderIteratorNode_incr(self)

    def decr(self) -> "void":
        return _freeling.TreePreorderIteratorNode_decr(self)

    def __eq__(self, t: 'TreePreorderIteratorNode') -> "bool":
        return _freeling.TreePreorderIteratorNode___eq__(self, t)

    def __ne__(self, t: 'TreePreorderIteratorNode') -> "bool":
        return _freeling.TreePreorderIteratorNode___ne__(self, t)

    def __ref__(self) -> "freeling::node &":
        return _freeling.TreePreorderIteratorNode___ref__(self)

    def __deref__(self) -> "freeling::node *":
        return _freeling.TreePreorderIteratorNode___deref__(self)

    def get_info(self) -> "freeling::node *":
        return _freeling.TreePreorderIteratorNode_get_info(self)

    def is_defined(self) -> "bool":
        return _freeling.TreePreorderIteratorNode_is_defined(self)

    def is_root(self) -> "bool":
        return _freeling.TreePreorderIteratorNode_is_root(self)

    def empty(self) -> "bool":
        return _freeling.TreePreorderIteratorNode_empty(self)

    def has_ancestor(self, p: 'TreeOfNode') -> "bool":
        return _freeling.TreePreorderIteratorNode_has_ancestor(self, p)

    def num_children(self) -> "unsigned int":
        return _freeling.TreePreorderIteratorNode_num_children(self)

    def get_parent(self) -> "freeling::tree_preorder_iterator< freeling::node >":
        return _freeling.TreePreorderIteratorNode_get_parent(self)

    def nth_child(self, arg2: 'unsigned int') -> "freeling::tree_sibling_iterator< freeling::node >":
        return _freeling.TreePreorderIteratorNode_nth_child(self, arg2)

    def nth_child_ref(self, arg2: 'unsigned int') -> "freeling::tree< freeling::node > &":
        return _freeling.TreePreorderIteratorNode_nth_child_ref(self, arg2)

    def begin(self) -> "freeling::tree_preorder_iterator< freeling::node >":
        return _freeling.TreePreorderIteratorNode_begin(self)

    def end(self) -> "freeling::tree_preorder_iterator< freeling::node >":
        return _freeling.TreePreorderIteratorNode_end(self)

    def sibling_begin(self) -> "freeling::tree_sibling_iterator< freeling::node >":
        return _freeling.TreePreorderIteratorNode_sibling_begin(self)

    def sibling_end(self) -> "freeling::tree_sibling_iterator< freeling::node >":
        return _freeling.TreePreorderIteratorNode_sibling_end(self)

    def sibling_rbegin(self) -> "freeling::tree_sibling_iterator< freeling::node >":
        return _freeling.TreePreorderIteratorNode_sibling_rbegin(self)

    def sibling_rend(self) -> "freeling::tree_sibling_iterator< freeling::node >":
        return _freeling.TreePreorderIteratorNode_sibling_rend(self)

    def add_child(self, t: 'TreeOfNode', last: 'bool'=True) -> "void":
        return _freeling.TreePreorderIteratorNode_add_child(self, t, last)

    def hang_child(self, *args) -> "void":
        return _freeling.TreePreorderIteratorNode_hang_child(self, *args)

    def get_node_id(self) -> "std::wstring":
        return _freeling.TreePreorderIteratorNode_get_node_id(self)

    def set_node_id(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.TreePreorderIteratorNode_set_node_id(self, arg2)

    def get_label(self) -> "std::wstring":
        return _freeling.TreePreorderIteratorNode_get_label(self)

    def has_word(self) -> "bool":
        return _freeling.TreePreorderIteratorNode_has_word(self)

    def get_word(self, *args) -> "freeling::word const &":
        return _freeling.TreePreorderIteratorNode_get_word(self, *args)

    def set_label(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.TreePreorderIteratorNode_set_label(self, arg2)

    def set_word(self, arg2: 'word') -> "void":
        return _freeling.TreePreorderIteratorNode_set_word(self, arg2)

    def is_head(self) -> "bool":
        return _freeling.TreePreorderIteratorNode_is_head(self)

    def set_head(self, arg2: 'bool const') -> "void":
        return _freeling.TreePreorderIteratorNode_set_head(self, arg2)

    def is_chunk(self) -> "bool":
        return _freeling.TreePreorderIteratorNode_is_chunk(self)

    def set_chunk(self, arg2: 'int const') -> "void":
        return _freeling.TreePreorderIteratorNode_set_chunk(self, arg2)

    def get_chunk_ord(self) -> "int":
        return _freeling.TreePreorderIteratorNode_get_chunk_ord(self)
TreePreorderIteratorNode_swigregister = _freeling.TreePreorderIteratorNode_swigregister
TreePreorderIteratorNode_swigregister(TreePreorderIteratorNode)

class TreeSiblingIteratorNode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeSiblingIteratorNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreeSiblingIteratorNode, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_TreeSiblingIteratorNode(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_TreeSiblingIteratorNode
    __del__ = lambda self: None

    def incr(self) -> "void":
        return _freeling.TreeSiblingIteratorNode_incr(self)

    def decr(self) -> "void":
        return _freeling.TreeSiblingIteratorNode_decr(self)

    def __ref__(self) -> "freeling::node &":
        return _freeling.TreeSiblingIteratorNode___ref__(self)

    def __deref__(self) -> "freeling::node *":
        return _freeling.TreeSiblingIteratorNode___deref__(self)

    def get_info(self) -> "freeling::node *":
        return _freeling.TreeSiblingIteratorNode_get_info(self)

    def __eq__(self, t: 'TreeSiblingIteratorNode') -> "bool":
        return _freeling.TreeSiblingIteratorNode___eq__(self, t)

    def __ne__(self, t: 'TreeSiblingIteratorNode') -> "bool":
        return _freeling.TreeSiblingIteratorNode___ne__(self, t)

    def get_parent(self) -> "freeling::tree_preorder_iterator< freeling::node >":
        return _freeling.TreeSiblingIteratorNode_get_parent(self)

    def nth_child(self, arg2: 'unsigned int') -> "freeling::tree_sibling_iterator< freeling::node >":
        return _freeling.TreeSiblingIteratorNode_nth_child(self, arg2)

    def nth_child_ref(self, arg2: 'unsigned int') -> "freeling::tree< freeling::node > &":
        return _freeling.TreeSiblingIteratorNode_nth_child_ref(self, arg2)

    def is_defined(self) -> "bool":
        return _freeling.TreeSiblingIteratorNode_is_defined(self)

    def is_root(self) -> "bool":
        return _freeling.TreeSiblingIteratorNode_is_root(self)

    def empty(self) -> "bool":
        return _freeling.TreeSiblingIteratorNode_empty(self)

    def has_ancestor(self, p: 'TreeOfNode') -> "bool":
        return _freeling.TreeSiblingIteratorNode_has_ancestor(self, p)

    def num_children(self) -> "unsigned int":
        return _freeling.TreeSiblingIteratorNode_num_children(self)

    def begin(self) -> "freeling::tree_preorder_iterator< freeling::node >":
        return _freeling.TreeSiblingIteratorNode_begin(self)

    def end(self) -> "freeling::tree_preorder_iterator< freeling::node >":
        return _freeling.TreeSiblingIteratorNode_end(self)

    def sibling_begin(self) -> "freeling::tree_sibling_iterator< freeling::node >":
        return _freeling.TreeSiblingIteratorNode_sibling_begin(self)

    def sibling_end(self) -> "freeling::tree_sibling_iterator< freeling::node >":
        return _freeling.TreeSiblingIteratorNode_sibling_end(self)

    def sibling_rbegin(self) -> "freeling::tree_sibling_iterator< freeling::node >":
        return _freeling.TreeSiblingIteratorNode_sibling_rbegin(self)

    def sibling_rend(self) -> "freeling::tree_sibling_iterator< freeling::node >":
        return _freeling.TreeSiblingIteratorNode_sibling_rend(self)

    def add_child(self, t: 'TreeOfNode', last: 'bool'=True) -> "void":
        return _freeling.TreeSiblingIteratorNode_add_child(self, t, last)

    def hang_child(self, *args) -> "void":
        return _freeling.TreeSiblingIteratorNode_hang_child(self, *args)

    def get_node_id(self) -> "std::wstring":
        return _freeling.TreeSiblingIteratorNode_get_node_id(self)

    def set_node_id(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.TreeSiblingIteratorNode_set_node_id(self, arg2)

    def get_label(self) -> "std::wstring":
        return _freeling.TreeSiblingIteratorNode_get_label(self)

    def has_word(self) -> "bool":
        return _freeling.TreeSiblingIteratorNode_has_word(self)

    def get_word(self, *args) -> "freeling::word const &":
        return _freeling.TreeSiblingIteratorNode_get_word(self, *args)

    def set_label(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.TreeSiblingIteratorNode_set_label(self, arg2)

    def set_word(self, arg2: 'word') -> "void":
        return _freeling.TreeSiblingIteratorNode_set_word(self, arg2)

    def is_head(self) -> "bool":
        return _freeling.TreeSiblingIteratorNode_is_head(self)

    def set_head(self, arg2: 'bool const') -> "void":
        return _freeling.TreeSiblingIteratorNode_set_head(self, arg2)

    def is_chunk(self) -> "bool":
        return _freeling.TreeSiblingIteratorNode_is_chunk(self)

    def set_chunk(self, arg2: 'int const') -> "void":
        return _freeling.TreeSiblingIteratorNode_set_chunk(self, arg2)

    def get_chunk_ord(self) -> "int":
        return _freeling.TreeSiblingIteratorNode_get_chunk_ord(self)
TreeSiblingIteratorNode_swigregister = _freeling.TreeSiblingIteratorNode_swigregister
TreeSiblingIteratorNode_swigregister(TreeSiblingIteratorNode)

class TreePreorderIteratorDepnode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreePreorderIteratorDepnode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreePreorderIteratorDepnode, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_TreePreorderIteratorDepnode(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_TreePreorderIteratorDepnode
    __del__ = lambda self: None

    def incr(self) -> "void":
        return _freeling.TreePreorderIteratorDepnode_incr(self)

    def decr(self) -> "void":
        return _freeling.TreePreorderIteratorDepnode_decr(self)

    def __eq__(self, t: 'TreePreorderIteratorDepnode') -> "bool":
        return _freeling.TreePreorderIteratorDepnode___eq__(self, t)

    def __ne__(self, t: 'TreePreorderIteratorDepnode') -> "bool":
        return _freeling.TreePreorderIteratorDepnode___ne__(self, t)

    def __ref__(self) -> "freeling::depnode &":
        return _freeling.TreePreorderIteratorDepnode___ref__(self)

    def __deref__(self) -> "freeling::depnode *":
        return _freeling.TreePreorderIteratorDepnode___deref__(self)

    def get_info(self) -> "freeling::depnode *":
        return _freeling.TreePreorderIteratorDepnode_get_info(self)

    def is_defined(self) -> "bool":
        return _freeling.TreePreorderIteratorDepnode_is_defined(self)

    def is_root(self) -> "bool":
        return _freeling.TreePreorderIteratorDepnode_is_root(self)

    def empty(self) -> "bool":
        return _freeling.TreePreorderIteratorDepnode_empty(self)

    def has_ancestor(self, p: 'TreeOfDepnode') -> "bool":
        return _freeling.TreePreorderIteratorDepnode_has_ancestor(self, p)

    def num_children(self) -> "unsigned int":
        return _freeling.TreePreorderIteratorDepnode_num_children(self)

    def get_parent(self) -> "freeling::tree_preorder_iterator< freeling::depnode >":
        return _freeling.TreePreorderIteratorDepnode_get_parent(self)

    def nth_child(self, arg2: 'unsigned int') -> "freeling::tree_sibling_iterator< freeling::depnode >":
        return _freeling.TreePreorderIteratorDepnode_nth_child(self, arg2)

    def nth_child_ref(self, arg2: 'unsigned int') -> "freeling::tree< freeling::depnode > &":
        return _freeling.TreePreorderIteratorDepnode_nth_child_ref(self, arg2)

    def begin(self) -> "freeling::tree_preorder_iterator< freeling::depnode >":
        return _freeling.TreePreorderIteratorDepnode_begin(self)

    def end(self) -> "freeling::tree_preorder_iterator< freeling::depnode >":
        return _freeling.TreePreorderIteratorDepnode_end(self)

    def sibling_begin(self) -> "freeling::tree_sibling_iterator< freeling::depnode >":
        return _freeling.TreePreorderIteratorDepnode_sibling_begin(self)

    def sibling_end(self) -> "freeling::tree_sibling_iterator< freeling::depnode >":
        return _freeling.TreePreorderIteratorDepnode_sibling_end(self)

    def sibling_rbegin(self) -> "freeling::tree_sibling_iterator< freeling::depnode >":
        return _freeling.TreePreorderIteratorDepnode_sibling_rbegin(self)

    def sibling_rend(self) -> "freeling::tree_sibling_iterator< freeling::depnode >":
        return _freeling.TreePreorderIteratorDepnode_sibling_rend(self)

    def add_child(self, t: 'TreeOfDepnode', last: 'bool'=True) -> "void":
        return _freeling.TreePreorderIteratorDepnode_add_child(self, t, last)

    def hang_child(self, *args) -> "void":
        return _freeling.TreePreorderIteratorDepnode_hang_child(self, *args)

    def set_link(self, arg2: 'TreePreorderIteratorNode') -> "void":
        return _freeling.TreePreorderIteratorDepnode_set_link(self, arg2)

    def get_link(self, *args) -> "freeling::parse_tree::const_iterator":
        return _freeling.TreePreorderIteratorDepnode_get_link(self, *args)

    def get_node_id(self) -> "std::wstring":
        return _freeling.TreePreorderIteratorDepnode_get_node_id(self)

    def set_node_id(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.TreePreorderIteratorDepnode_set_node_id(self, arg2)

    def get_label(self) -> "std::wstring":
        return _freeling.TreePreorderIteratorDepnode_get_label(self)

    def has_word(self) -> "bool":
        return _freeling.TreePreorderIteratorDepnode_has_word(self)

    def get_word(self, *args) -> "freeling::word const &":
        return _freeling.TreePreorderIteratorDepnode_get_word(self, *args)

    def set_label(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.TreePreorderIteratorDepnode_set_label(self, arg2)

    def set_word(self, arg2: 'word') -> "void":
        return _freeling.TreePreorderIteratorDepnode_set_word(self, arg2)

    def is_head(self) -> "bool":
        return _freeling.TreePreorderIteratorDepnode_is_head(self)

    def set_head(self, arg2: 'bool const') -> "void":
        return _freeling.TreePreorderIteratorDepnode_set_head(self, arg2)

    def is_chunk(self) -> "bool":
        return _freeling.TreePreorderIteratorDepnode_is_chunk(self)

    def set_chunk(self, arg2: 'int const') -> "void":
        return _freeling.TreePreorderIteratorDepnode_set_chunk(self, arg2)

    def get_chunk_ord(self) -> "int":
        return _freeling.TreePreorderIteratorDepnode_get_chunk_ord(self)
TreePreorderIteratorDepnode_swigregister = _freeling.TreePreorderIteratorDepnode_swigregister
TreePreorderIteratorDepnode_swigregister(TreePreorderIteratorDepnode)

class TreeSiblingIteratorDepnode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeSiblingIteratorDepnode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreeSiblingIteratorDepnode, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_TreeSiblingIteratorDepnode(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_TreeSiblingIteratorDepnode
    __del__ = lambda self: None

    def incr(self) -> "void":
        return _freeling.TreeSiblingIteratorDepnode_incr(self)

    def decr(self) -> "void":
        return _freeling.TreeSiblingIteratorDepnode_decr(self)

    def __ref__(self) -> "freeling::depnode &":
        return _freeling.TreeSiblingIteratorDepnode___ref__(self)

    def __deref__(self) -> "freeling::depnode *":
        return _freeling.TreeSiblingIteratorDepnode___deref__(self)

    def get_info(self) -> "freeling::depnode *":
        return _freeling.TreeSiblingIteratorDepnode_get_info(self)

    def __eq__(self, t: 'TreeSiblingIteratorDepnode') -> "bool":
        return _freeling.TreeSiblingIteratorDepnode___eq__(self, t)

    def __ne__(self, t: 'TreeSiblingIteratorDepnode') -> "bool":
        return _freeling.TreeSiblingIteratorDepnode___ne__(self, t)

    def get_parent(self) -> "freeling::tree_preorder_iterator< freeling::depnode >":
        return _freeling.TreeSiblingIteratorDepnode_get_parent(self)

    def nth_child(self, arg2: 'unsigned int') -> "freeling::tree_sibling_iterator< freeling::depnode >":
        return _freeling.TreeSiblingIteratorDepnode_nth_child(self, arg2)

    def nth_child_ref(self, arg2: 'unsigned int') -> "freeling::tree< freeling::depnode > &":
        return _freeling.TreeSiblingIteratorDepnode_nth_child_ref(self, arg2)

    def is_defined(self) -> "bool":
        return _freeling.TreeSiblingIteratorDepnode_is_defined(self)

    def is_root(self) -> "bool":
        return _freeling.TreeSiblingIteratorDepnode_is_root(self)

    def empty(self) -> "bool":
        return _freeling.TreeSiblingIteratorDepnode_empty(self)

    def has_ancestor(self, p: 'TreeOfDepnode') -> "bool":
        return _freeling.TreeSiblingIteratorDepnode_has_ancestor(self, p)

    def num_children(self) -> "unsigned int":
        return _freeling.TreeSiblingIteratorDepnode_num_children(self)

    def begin(self) -> "freeling::tree_preorder_iterator< freeling::depnode >":
        return _freeling.TreeSiblingIteratorDepnode_begin(self)

    def end(self) -> "freeling::tree_preorder_iterator< freeling::depnode >":
        return _freeling.TreeSiblingIteratorDepnode_end(self)

    def sibling_begin(self) -> "freeling::tree_sibling_iterator< freeling::depnode >":
        return _freeling.TreeSiblingIteratorDepnode_sibling_begin(self)

    def sibling_end(self) -> "freeling::tree_sibling_iterator< freeling::depnode >":
        return _freeling.TreeSiblingIteratorDepnode_sibling_end(self)

    def sibling_rbegin(self) -> "freeling::tree_sibling_iterator< freeling::depnode >":
        return _freeling.TreeSiblingIteratorDepnode_sibling_rbegin(self)

    def sibling_rend(self) -> "freeling::tree_sibling_iterator< freeling::depnode >":
        return _freeling.TreeSiblingIteratorDepnode_sibling_rend(self)

    def add_child(self, t: 'TreeOfDepnode', last: 'bool'=True) -> "void":
        return _freeling.TreeSiblingIteratorDepnode_add_child(self, t, last)

    def hang_child(self, *args) -> "void":
        return _freeling.TreeSiblingIteratorDepnode_hang_child(self, *args)

    def set_link(self, arg2: 'TreePreorderIteratorNode') -> "void":
        return _freeling.TreeSiblingIteratorDepnode_set_link(self, arg2)

    def get_link(self, *args) -> "freeling::parse_tree::const_iterator":
        return _freeling.TreeSiblingIteratorDepnode_get_link(self, *args)

    def get_node_id(self) -> "std::wstring":
        return _freeling.TreeSiblingIteratorDepnode_get_node_id(self)

    def set_node_id(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.TreeSiblingIteratorDepnode_set_node_id(self, arg2)

    def get_label(self) -> "std::wstring":
        return _freeling.TreeSiblingIteratorDepnode_get_label(self)

    def has_word(self) -> "bool":
        return _freeling.TreeSiblingIteratorDepnode_has_word(self)

    def get_word(self, *args) -> "freeling::word const &":
        return _freeling.TreeSiblingIteratorDepnode_get_word(self, *args)

    def set_label(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.TreeSiblingIteratorDepnode_set_label(self, arg2)

    def set_word(self, arg2: 'word') -> "void":
        return _freeling.TreeSiblingIteratorDepnode_set_word(self, arg2)

    def is_head(self) -> "bool":
        return _freeling.TreeSiblingIteratorDepnode_is_head(self)

    def set_head(self, arg2: 'bool const') -> "void":
        return _freeling.TreeSiblingIteratorDepnode_set_head(self, arg2)

    def is_chunk(self) -> "bool":
        return _freeling.TreeSiblingIteratorDepnode_is_chunk(self)

    def set_chunk(self, arg2: 'int const') -> "void":
        return _freeling.TreeSiblingIteratorDepnode_set_chunk(self, arg2)

    def get_chunk_ord(self) -> "int":
        return _freeling.TreeSiblingIteratorDepnode_get_chunk_ord(self)
TreeSiblingIteratorDepnode_swigregister = _freeling.TreeSiblingIteratorDepnode_swigregister
TreeSiblingIteratorDepnode_swigregister(TreeSiblingIteratorDepnode)

class TreeConstPreorderIteratorNode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeConstPreorderIteratorNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreeConstPreorderIteratorNode, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_TreeConstPreorderIteratorNode(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_TreeConstPreorderIteratorNode
    __del__ = lambda self: None

    def __ref__(self) -> "freeling::node const &":
        return _freeling.TreeConstPreorderIteratorNode___ref__(self)

    def __deref__(self) -> "freeling::node const *":
        return _freeling.TreeConstPreorderIteratorNode___deref__(self)

    def incr(self) -> "void":
        return _freeling.TreeConstPreorderIteratorNode_incr(self)

    def decr(self) -> "void":
        return _freeling.TreeConstPreorderIteratorNode_decr(self)

    def __eq__(self, t: 'TreeConstPreorderIteratorNode') -> "bool":
        return _freeling.TreeConstPreorderIteratorNode___eq__(self, t)

    def __ne__(self, t: 'TreeConstPreorderIteratorNode') -> "bool":
        return _freeling.TreeConstPreorderIteratorNode___ne__(self, t)

    def get_info(self) -> "freeling::node const *":
        return _freeling.TreeConstPreorderIteratorNode_get_info(self)

    def is_defined(self) -> "bool":
        return _freeling.TreeConstPreorderIteratorNode_is_defined(self)

    def is_root(self) -> "bool":
        return _freeling.TreeConstPreorderIteratorNode_is_root(self)

    def empty(self) -> "bool":
        return _freeling.TreeConstPreorderIteratorNode_empty(self)

    def has_ancestor(self, p: 'TreeOfNode') -> "bool":
        return _freeling.TreeConstPreorderIteratorNode_has_ancestor(self, p)

    def num_children(self) -> "unsigned int":
        return _freeling.TreeConstPreorderIteratorNode_num_children(self)

    def get_parent(self) -> "freeling::const_tree_preorder_iterator< freeling::node >":
        return _freeling.TreeConstPreorderIteratorNode_get_parent(self)

    def nth_child(self, n: 'unsigned int') -> "freeling::const_tree_sibling_iterator< freeling::node >":
        return _freeling.TreeConstPreorderIteratorNode_nth_child(self, n)

    def nth_child_ref(self, n: 'unsigned int') -> "freeling::tree< freeling::node > const &":
        return _freeling.TreeConstPreorderIteratorNode_nth_child_ref(self, n)

    def begin(self) -> "freeling::const_tree_preorder_iterator< freeling::node >":
        return _freeling.TreeConstPreorderIteratorNode_begin(self)

    def end(self) -> "freeling::const_tree_preorder_iterator< freeling::node >":
        return _freeling.TreeConstPreorderIteratorNode_end(self)

    def sibling_begin(self) -> "freeling::const_tree_sibling_iterator< freeling::node >":
        return _freeling.TreeConstPreorderIteratorNode_sibling_begin(self)

    def sibling_end(self) -> "freeling::const_tree_sibling_iterator< freeling::node >":
        return _freeling.TreeConstPreorderIteratorNode_sibling_end(self)

    def sibling_rbegin(self) -> "freeling::const_tree_sibling_iterator< freeling::node >":
        return _freeling.TreeConstPreorderIteratorNode_sibling_rbegin(self)

    def sibling_rend(self) -> "freeling::const_tree_sibling_iterator< freeling::node >":
        return _freeling.TreeConstPreorderIteratorNode_sibling_rend(self)

    def get_node_id(self) -> "std::wstring":
        return _freeling.TreeConstPreorderIteratorNode_get_node_id(self)

    def get_label(self) -> "std::wstring":
        return _freeling.TreeConstPreorderIteratorNode_get_label(self)

    def has_word(self) -> "bool":
        return _freeling.TreeConstPreorderIteratorNode_has_word(self)

    def get_word(self, *args) -> "freeling::word const &":
        return _freeling.TreeConstPreorderIteratorNode_get_word(self, *args)

    def is_head(self) -> "bool":
        return _freeling.TreeConstPreorderIteratorNode_is_head(self)

    def is_chunk(self) -> "bool":
        return _freeling.TreeConstPreorderIteratorNode_is_chunk(self)

    def get_chunk_ord(self) -> "int":
        return _freeling.TreeConstPreorderIteratorNode_get_chunk_ord(self)
TreeConstPreorderIteratorNode_swigregister = _freeling.TreeConstPreorderIteratorNode_swigregister
TreeConstPreorderIteratorNode_swigregister(TreeConstPreorderIteratorNode)

class TreeConstSiblingIteratorNode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeConstSiblingIteratorNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreeConstSiblingIteratorNode, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_TreeConstSiblingIteratorNode(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_TreeConstSiblingIteratorNode
    __del__ = lambda self: None

    def __ref__(self) -> "freeling::node const &":
        return _freeling.TreeConstSiblingIteratorNode___ref__(self)

    def __deref__(self) -> "freeling::node const *":
        return _freeling.TreeConstSiblingIteratorNode___deref__(self)

    def incr(self) -> "void":
        return _freeling.TreeConstSiblingIteratorNode_incr(self)

    def decr(self) -> "void":
        return _freeling.TreeConstSiblingIteratorNode_decr(self)

    def __eq__(self, t: 'TreeConstSiblingIteratorNode') -> "bool":
        return _freeling.TreeConstSiblingIteratorNode___eq__(self, t)

    def __ne__(self, t: 'TreeConstSiblingIteratorNode') -> "bool":
        return _freeling.TreeConstSiblingIteratorNode___ne__(self, t)

    def get_info(self) -> "freeling::node const *":
        return _freeling.TreeConstSiblingIteratorNode_get_info(self)

    def is_defined(self) -> "bool":
        return _freeling.TreeConstSiblingIteratorNode_is_defined(self)

    def is_root(self) -> "bool":
        return _freeling.TreeConstSiblingIteratorNode_is_root(self)

    def empty(self) -> "bool":
        return _freeling.TreeConstSiblingIteratorNode_empty(self)

    def has_ancestor(self, p: 'TreeOfNode') -> "bool":
        return _freeling.TreeConstSiblingIteratorNode_has_ancestor(self, p)

    def num_children(self) -> "unsigned int":
        return _freeling.TreeConstSiblingIteratorNode_num_children(self)

    def get_parent(self) -> "freeling::const_tree_preorder_iterator< freeling::node >":
        return _freeling.TreeConstSiblingIteratorNode_get_parent(self)

    def nth_child(self, n: 'unsigned int') -> "freeling::const_tree_sibling_iterator< freeling::node >":
        return _freeling.TreeConstSiblingIteratorNode_nth_child(self, n)

    def nth_child_ref(self, n: 'unsigned int') -> "freeling::tree< freeling::node > const &":
        return _freeling.TreeConstSiblingIteratorNode_nth_child_ref(self, n)

    def begin(self) -> "freeling::const_tree_preorder_iterator< freeling::node >":
        return _freeling.TreeConstSiblingIteratorNode_begin(self)

    def end(self) -> "freeling::const_tree_preorder_iterator< freeling::node >":
        return _freeling.TreeConstSiblingIteratorNode_end(self)

    def sibling_begin(self) -> "freeling::const_tree_sibling_iterator< freeling::node >":
        return _freeling.TreeConstSiblingIteratorNode_sibling_begin(self)

    def sibling_end(self) -> "freeling::const_tree_sibling_iterator< freeling::node >":
        return _freeling.TreeConstSiblingIteratorNode_sibling_end(self)

    def sibling_rbegin(self) -> "freeling::const_tree_sibling_iterator< freeling::node >":
        return _freeling.TreeConstSiblingIteratorNode_sibling_rbegin(self)

    def sibling_rend(self) -> "freeling::const_tree_sibling_iterator< freeling::node >":
        return _freeling.TreeConstSiblingIteratorNode_sibling_rend(self)

    def get_node_id(self) -> "std::wstring":
        return _freeling.TreeConstSiblingIteratorNode_get_node_id(self)

    def get_label(self) -> "std::wstring":
        return _freeling.TreeConstSiblingIteratorNode_get_label(self)

    def has_word(self) -> "bool":
        return _freeling.TreeConstSiblingIteratorNode_has_word(self)

    def get_word(self, *args) -> "freeling::word const &":
        return _freeling.TreeConstSiblingIteratorNode_get_word(self, *args)

    def is_head(self) -> "bool":
        return _freeling.TreeConstSiblingIteratorNode_is_head(self)

    def is_chunk(self) -> "bool":
        return _freeling.TreeConstSiblingIteratorNode_is_chunk(self)

    def get_chunk_ord(self) -> "int":
        return _freeling.TreeConstSiblingIteratorNode_get_chunk_ord(self)
TreeConstSiblingIteratorNode_swigregister = _freeling.TreeConstSiblingIteratorNode_swigregister
TreeConstSiblingIteratorNode_swigregister(TreeConstSiblingIteratorNode)

class TreeConstPreorderIteratorDepnode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeConstPreorderIteratorDepnode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreeConstPreorderIteratorDepnode, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_TreeConstPreorderIteratorDepnode(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_TreeConstPreorderIteratorDepnode
    __del__ = lambda self: None

    def __ref__(self) -> "freeling::depnode const &":
        return _freeling.TreeConstPreorderIteratorDepnode___ref__(self)

    def __deref__(self) -> "freeling::depnode const *":
        return _freeling.TreeConstPreorderIteratorDepnode___deref__(self)

    def incr(self) -> "void":
        return _freeling.TreeConstPreorderIteratorDepnode_incr(self)

    def decr(self) -> "void":
        return _freeling.TreeConstPreorderIteratorDepnode_decr(self)

    def __eq__(self, t: 'TreeConstPreorderIteratorDepnode') -> "bool":
        return _freeling.TreeConstPreorderIteratorDepnode___eq__(self, t)

    def __ne__(self, t: 'TreeConstPreorderIteratorDepnode') -> "bool":
        return _freeling.TreeConstPreorderIteratorDepnode___ne__(self, t)

    def get_info(self) -> "freeling::depnode const *":
        return _freeling.TreeConstPreorderIteratorDepnode_get_info(self)

    def is_defined(self) -> "bool":
        return _freeling.TreeConstPreorderIteratorDepnode_is_defined(self)

    def is_root(self) -> "bool":
        return _freeling.TreeConstPreorderIteratorDepnode_is_root(self)

    def empty(self) -> "bool":
        return _freeling.TreeConstPreorderIteratorDepnode_empty(self)

    def has_ancestor(self, p: 'TreeOfDepnode') -> "bool":
        return _freeling.TreeConstPreorderIteratorDepnode_has_ancestor(self, p)

    def num_children(self) -> "unsigned int":
        return _freeling.TreeConstPreorderIteratorDepnode_num_children(self)

    def get_parent(self) -> "freeling::const_tree_preorder_iterator< freeling::depnode >":
        return _freeling.TreeConstPreorderIteratorDepnode_get_parent(self)

    def nth_child(self, n: 'unsigned int') -> "freeling::const_tree_sibling_iterator< freeling::depnode >":
        return _freeling.TreeConstPreorderIteratorDepnode_nth_child(self, n)

    def nth_child_ref(self, n: 'unsigned int') -> "freeling::tree< freeling::depnode > const &":
        return _freeling.TreeConstPreorderIteratorDepnode_nth_child_ref(self, n)

    def begin(self) -> "freeling::const_tree_preorder_iterator< freeling::depnode >":
        return _freeling.TreeConstPreorderIteratorDepnode_begin(self)

    def end(self) -> "freeling::const_tree_preorder_iterator< freeling::depnode >":
        return _freeling.TreeConstPreorderIteratorDepnode_end(self)

    def sibling_begin(self) -> "freeling::const_tree_sibling_iterator< freeling::depnode >":
        return _freeling.TreeConstPreorderIteratorDepnode_sibling_begin(self)

    def sibling_end(self) -> "freeling::const_tree_sibling_iterator< freeling::depnode >":
        return _freeling.TreeConstPreorderIteratorDepnode_sibling_end(self)

    def sibling_rbegin(self) -> "freeling::const_tree_sibling_iterator< freeling::depnode >":
        return _freeling.TreeConstPreorderIteratorDepnode_sibling_rbegin(self)

    def sibling_rend(self) -> "freeling::const_tree_sibling_iterator< freeling::depnode >":
        return _freeling.TreeConstPreorderIteratorDepnode_sibling_rend(self)

    def get_link(self, *args) -> "freeling::parse_tree::const_iterator":
        return _freeling.TreeConstPreorderIteratorDepnode_get_link(self, *args)

    def get_node_id(self) -> "std::wstring":
        return _freeling.TreeConstPreorderIteratorDepnode_get_node_id(self)

    def get_label(self) -> "std::wstring":
        return _freeling.TreeConstPreorderIteratorDepnode_get_label(self)

    def has_word(self) -> "bool":
        return _freeling.TreeConstPreorderIteratorDepnode_has_word(self)

    def get_word(self, *args) -> "freeling::word const &":
        return _freeling.TreeConstPreorderIteratorDepnode_get_word(self, *args)

    def is_head(self) -> "bool":
        return _freeling.TreeConstPreorderIteratorDepnode_is_head(self)

    def is_chunk(self) -> "bool":
        return _freeling.TreeConstPreorderIteratorDepnode_is_chunk(self)

    def get_chunk_ord(self) -> "int":
        return _freeling.TreeConstPreorderIteratorDepnode_get_chunk_ord(self)
TreeConstPreorderIteratorDepnode_swigregister = _freeling.TreeConstPreorderIteratorDepnode_swigregister
TreeConstPreorderIteratorDepnode_swigregister(TreeConstPreorderIteratorDepnode)

class TreeConstSiblingIteratorDepnode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeConstSiblingIteratorDepnode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreeConstSiblingIteratorDepnode, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_TreeConstSiblingIteratorDepnode(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_TreeConstSiblingIteratorDepnode
    __del__ = lambda self: None

    def __ref__(self) -> "freeling::depnode const &":
        return _freeling.TreeConstSiblingIteratorDepnode___ref__(self)

    def __deref__(self) -> "freeling::depnode const *":
        return _freeling.TreeConstSiblingIteratorDepnode___deref__(self)

    def incr(self) -> "void":
        return _freeling.TreeConstSiblingIteratorDepnode_incr(self)

    def decr(self) -> "void":
        return _freeling.TreeConstSiblingIteratorDepnode_decr(self)

    def __eq__(self, t: 'TreeConstSiblingIteratorDepnode') -> "bool":
        return _freeling.TreeConstSiblingIteratorDepnode___eq__(self, t)

    def __ne__(self, t: 'TreeConstSiblingIteratorDepnode') -> "bool":
        return _freeling.TreeConstSiblingIteratorDepnode___ne__(self, t)

    def get_info(self) -> "freeling::depnode const *":
        return _freeling.TreeConstSiblingIteratorDepnode_get_info(self)

    def is_defined(self) -> "bool":
        return _freeling.TreeConstSiblingIteratorDepnode_is_defined(self)

    def is_root(self) -> "bool":
        return _freeling.TreeConstSiblingIteratorDepnode_is_root(self)

    def empty(self) -> "bool":
        return _freeling.TreeConstSiblingIteratorDepnode_empty(self)

    def has_ancestor(self, p: 'TreeOfDepnode') -> "bool":
        return _freeling.TreeConstSiblingIteratorDepnode_has_ancestor(self, p)

    def num_children(self) -> "unsigned int":
        return _freeling.TreeConstSiblingIteratorDepnode_num_children(self)

    def get_parent(self) -> "freeling::const_tree_preorder_iterator< freeling::depnode >":
        return _freeling.TreeConstSiblingIteratorDepnode_get_parent(self)

    def nth_child(self, n: 'unsigned int') -> "freeling::const_tree_sibling_iterator< freeling::depnode >":
        return _freeling.TreeConstSiblingIteratorDepnode_nth_child(self, n)

    def nth_child_ref(self, n: 'unsigned int') -> "freeling::tree< freeling::depnode > const &":
        return _freeling.TreeConstSiblingIteratorDepnode_nth_child_ref(self, n)

    def begin(self) -> "freeling::const_tree_preorder_iterator< freeling::depnode >":
        return _freeling.TreeConstSiblingIteratorDepnode_begin(self)

    def end(self) -> "freeling::const_tree_preorder_iterator< freeling::depnode >":
        return _freeling.TreeConstSiblingIteratorDepnode_end(self)

    def sibling_begin(self) -> "freeling::const_tree_sibling_iterator< freeling::depnode >":
        return _freeling.TreeConstSiblingIteratorDepnode_sibling_begin(self)

    def sibling_end(self) -> "freeling::const_tree_sibling_iterator< freeling::depnode >":
        return _freeling.TreeConstSiblingIteratorDepnode_sibling_end(self)

    def sibling_rbegin(self) -> "freeling::const_tree_sibling_iterator< freeling::depnode >":
        return _freeling.TreeConstSiblingIteratorDepnode_sibling_rbegin(self)

    def sibling_rend(self) -> "freeling::const_tree_sibling_iterator< freeling::depnode >":
        return _freeling.TreeConstSiblingIteratorDepnode_sibling_rend(self)

    def get_link(self, *args) -> "freeling::parse_tree::const_iterator":
        return _freeling.TreeConstSiblingIteratorDepnode_get_link(self, *args)

    def get_node_id(self) -> "std::wstring":
        return _freeling.TreeConstSiblingIteratorDepnode_get_node_id(self)

    def get_label(self) -> "std::wstring":
        return _freeling.TreeConstSiblingIteratorDepnode_get_label(self)

    def has_word(self) -> "bool":
        return _freeling.TreeConstSiblingIteratorDepnode_has_word(self)

    def get_word(self, *args) -> "freeling::word const &":
        return _freeling.TreeConstSiblingIteratorDepnode_get_word(self, *args)

    def is_head(self) -> "bool":
        return _freeling.TreeConstSiblingIteratorDepnode_is_head(self)

    def is_chunk(self) -> "bool":
        return _freeling.TreeConstSiblingIteratorDepnode_is_chunk(self)

    def get_chunk_ord(self) -> "int":
        return _freeling.TreeConstSiblingIteratorDepnode_get_chunk_ord(self)
TreeConstSiblingIteratorDepnode_swigregister = _freeling.TreeConstSiblingIteratorDepnode_swigregister
TreeConstSiblingIteratorDepnode_swigregister(TreeConstSiblingIteratorDepnode)

class analysis(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, analysis, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, analysis, name)
    __repr__ = _swig_repr
    __swig_setmethods__["user"] = _freeling.analysis_user_set
    __swig_getmethods__["user"] = _freeling.analysis_user_get
    if _newclass:
        user = _swig_property(_freeling.analysis_user_get, _freeling.analysis_user_set)

    def __init__(self, *args):
        this = _freeling.new_analysis(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_analysis
    __del__ = lambda self: None

    def init(self, l: 'std::wstring const &', t: 'std::wstring const &') -> "void":
        return _freeling.analysis_init(self, l, t)

    def set_lemma(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.analysis_set_lemma(self, arg2)

    def set_tag(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.analysis_set_tag(self, arg2)

    def set_prob(self, arg2: 'double') -> "void":
        return _freeling.analysis_set_prob(self, arg2)

    def set_distance(self, arg2: 'double') -> "void":
        return _freeling.analysis_set_distance(self, arg2)

    def set_retokenizable(self, arg2: 'ListWord') -> "void":
        return _freeling.analysis_set_retokenizable(self, arg2)

    def has_prob(self) -> "bool":
        return _freeling.analysis_has_prob(self)

    def has_distance(self) -> "bool":
        return _freeling.analysis_has_distance(self)

    def get_lemma(self) -> "std::wstring":
        return _freeling.analysis_get_lemma(self)

    def get_tag(self) -> "std::wstring":
        return _freeling.analysis_get_tag(self)

    def get_prob(self) -> "double":
        return _freeling.analysis_get_prob(self)

    def get_distance(self) -> "double":
        return _freeling.analysis_get_distance(self)

    def is_retokenizable(self) -> "bool":
        return _freeling.analysis_is_retokenizable(self)

    def get_retokenizable(self) -> "std::list< freeling::word,std::allocator< freeling::word > >":
        return _freeling.analysis_get_retokenizable(self)

    def get_senses(self) -> "std::list< std::pair< std::wstring,double >,std::allocator< std::pair< std::wstring,double > > >":
        return _freeling.analysis_get_senses(self)

    def set_senses(self, arg2: 'ListPairStringDouble') -> "void":
        return _freeling.analysis_set_senses(self, arg2)

    def get_senses_string(self) -> "std::wstring":
        return _freeling.analysis_get_senses_string(self)

    def __gt__(self, arg2: 'analysis') -> "bool":
        return _freeling.analysis___gt__(self, arg2)

    def __lt__(self, arg2: 'analysis') -> "bool":
        return _freeling.analysis___lt__(self, arg2)

    def __eq__(self, arg2: 'analysis') -> "bool":
        return _freeling.analysis___eq__(self, arg2)

    def is_selected(self, k: 'int'=0) -> "bool":
        return _freeling.analysis_is_selected(self, k)

    def mark_selected(self, k: 'int'=0) -> "void":
        return _freeling.analysis_mark_selected(self, k)

    def unmark_selected(self, k: 'int'=0) -> "void":
        return _freeling.analysis_unmark_selected(self, k)
analysis_swigregister = _freeling.analysis_swigregister
analysis_swigregister(analysis)

class alternative(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, alternative, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, alternative, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_alternative(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def __eq__(self, arg2: 'alternative') -> "bool":
        return _freeling.alternative___eq__(self, arg2)

    def get_form(self) -> "std::wstring":
        return _freeling.alternative_get_form(self)

    def get_distance(self) -> "int":
        return _freeling.alternative_get_distance(self)

    def get_probability(self) -> "float":
        return _freeling.alternative_get_probability(self)

    def is_selected(self, k: 'int'=1) -> "bool":
        return _freeling.alternative_is_selected(self, k)

    def clear_selections(self) -> "void":
        return _freeling.alternative_clear_selections(self)

    def add_selection(self, arg2: 'int') -> "void":
        return _freeling.alternative_add_selection(self, arg2)

    def set_form(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.alternative_set_form(self, arg2)

    def set_distance(self, arg2: 'int') -> "void":
        return _freeling.alternative_set_distance(self, arg2)

    def set_probability(self, arg2: 'float') -> "void":
        return _freeling.alternative_set_probability(self, arg2)
    __swig_destroy__ = _freeling.delete_alternative
    __del__ = lambda self: None
alternative_swigregister = _freeling.alternative_swigregister
alternative_swigregister(alternative)

class word(ListAnalysis):
    __swig_setmethods__ = {}
    for _s in [ListAnalysis]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, word, name, value)
    __swig_getmethods__ = {}
    for _s in [ListAnalysis]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, word, name)
    __repr__ = _swig_repr
    USERMAP = _freeling.word_USERMAP
    NUMBERS = _freeling.word_NUMBERS
    PUNCTUATION = _freeling.word_PUNCTUATION
    DATES = _freeling.word_DATES
    DICTIONARY = _freeling.word_DICTIONARY
    AFFIXES = _freeling.word_AFFIXES
    COMPOUNDS = _freeling.word_COMPOUNDS
    MULTIWORDS = _freeling.word_MULTIWORDS
    NER = _freeling.word_NER
    QUANTITIES = _freeling.word_QUANTITIES
    PROBABILITIES = _freeling.word_PROBABILITIES
    GUESSER = _freeling.word_GUESSER
    __swig_setmethods__["user"] = _freeling.word_user_set
    __swig_getmethods__["user"] = _freeling.word_user_get
    if _newclass:
        user = _swig_property(_freeling.word_user_get, _freeling.word_user_set)

    def __init__(self, *args):
        this = _freeling.new_word(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_word
    __del__ = lambda self: None

    def copy_analysis(self, arg2: 'word') -> "void":
        return _freeling.word_copy_analysis(self, arg2)

    def get_n_selected(self) -> "int":
        return _freeling.word_get_n_selected(self)

    def get_n_unselected(self) -> "int":
        return _freeling.word_get_n_unselected(self)

    def is_multiword(self) -> "bool":
        return _freeling.word_is_multiword(self)

    def is_ambiguous_mw(self) -> "bool":
        return _freeling.word_is_ambiguous_mw(self)

    def set_ambiguous_mw(self, arg2: 'bool') -> "void":
        return _freeling.word_set_ambiguous_mw(self, arg2)

    def get_n_words_mw(self) -> "int":
        return _freeling.word_get_n_words_mw(self)

    def get_words_mw(self) -> "std::list< freeling::word,std::allocator< freeling::word > > const &":
        return _freeling.word_get_words_mw(self)

    def get_form(self) -> "std::wstring":
        return _freeling.word_get_form(self)

    def get_lc_form(self) -> "std::wstring":
        return _freeling.word_get_lc_form(self)

    def get_ph_form(self) -> "std::wstring":
        return _freeling.word_get_ph_form(self)

    def selected_begin(self, *args) -> "freeling::word::const_iterator":
        return _freeling.word_selected_begin(self, *args)

    def selected_end(self, *args) -> "freeling::word::const_iterator":
        return _freeling.word_selected_end(self, *args)

    def unselected_begin(self, *args) -> "freeling::word::const_iterator":
        return _freeling.word_unselected_begin(self, *args)

    def unselected_end(self, *args) -> "freeling::word::const_iterator":
        return _freeling.word_unselected_end(self, *args)

    def num_kbest(self) -> "unsigned int":
        return _freeling.word_num_kbest(self)

    def get_lemma(self, k: 'int'=0) -> "std::wstring":
        return _freeling.word_get_lemma(self, k)

    def get_tag(self, k: 'int'=0) -> "std::wstring":
        return _freeling.word_get_tag(self, k)

    def get_senses(self, k: 'int'=0) -> "std::list< std::pair< std::wstring,double >,std::allocator< std::pair< std::wstring,double > > >":
        return _freeling.word_get_senses(self, k)

    def get_senses_string(self, k: 'int'=0) -> "std::wstring":
        return _freeling.word_get_senses_string(self, k)

    def set_senses(self, arg2: 'ListPairStringDouble', k: 'int'=0) -> "void":
        return _freeling.word_set_senses(self, arg2, k)

    def get_span_start(self) -> "unsigned long":
        return _freeling.word_get_span_start(self)

    def get_span_finish(self) -> "unsigned long":
        return _freeling.word_get_span_finish(self)

    def has_retokenizable(self) -> "bool":
        return _freeling.word_has_retokenizable(self)

    def lock_analysis(self) -> "void":
        return _freeling.word_lock_analysis(self)

    def unlock_analysis(self) -> "void":
        return _freeling.word_unlock_analysis(self)

    def is_locked_analysis(self) -> "bool":
        return _freeling.word_is_locked_analysis(self)

    def lock_multiwords(self) -> "void":
        return _freeling.word_lock_multiwords(self)

    def unlock_multiwords(self) -> "void":
        return _freeling.word_unlock_multiwords(self)

    def is_locked_multiwords(self) -> "bool":
        return _freeling.word_is_locked_multiwords(self)

    def set_analyzed_by(self, arg2: 'unsigned int') -> "void":
        return _freeling.word_set_analyzed_by(self, arg2)

    def is_analyzed_by(self, arg2: 'unsigned int') -> "bool":
        return _freeling.word_is_analyzed_by(self, arg2)

    def get_analyzed_by(self) -> "unsigned int":
        return _freeling.word_get_analyzed_by(self)

    def add_alternative(self, *args) -> "void":
        return _freeling.word_add_alternative(self, *args)

    def set_alternatives(self, arg2: 'std::list< std::pair< std::wstring,int >,std::allocator< std::pair< std::wstring,int > > > const &') -> "void":
        return _freeling.word_set_alternatives(self, arg2)

    def clear_alternatives(self) -> "void":
        return _freeling.word_clear_alternatives(self)

    def has_alternatives(self) -> "bool":
        return _freeling.word_has_alternatives(self)

    def get_alternatives(self, *args) -> "std::list< freeling::alternative,std::allocator< freeling::alternative > > const &":
        return _freeling.word_get_alternatives(self, *args)

    def alternatives_begin(self, *args) -> "std::list< freeling::alternative,std::allocator< freeling::alternative > >::const_iterator":
        return _freeling.word_alternatives_begin(self, *args)

    def alternatives_end(self, *args) -> "std::list< freeling::alternative,std::allocator< freeling::alternative > >::const_iterator":
        return _freeling.word_alternatives_end(self, *args)

    def add_analysis(self, arg2: 'analysis') -> "void":
        return _freeling.word_add_analysis(self, arg2)

    def set_analysis(self, *args) -> "void":
        return _freeling.word_set_analysis(self, *args)

    def set_form(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.word_set_form(self, arg2)

    def set_ph_form(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.word_set_ph_form(self, arg2)

    def set_span(self, arg2: 'unsigned long', arg3: 'unsigned long') -> "void":
        return _freeling.word_set_span(self, arg2, arg3)

    def set_position(self, arg2: 'size_t') -> "void":
        return _freeling.word_set_position(self, arg2)

    def get_position(self) -> "size_t":
        return _freeling.word_get_position(self)

    def find_tag_match(self, arg2: 'freeling::regexp &') -> "bool":
        return _freeling.word_find_tag_match(self, arg2)

    def get_n_analysis(self) -> "int":
        return _freeling.word_get_n_analysis(self)

    def unselect_all_analysis(self, k: 'int'=0) -> "void":
        return _freeling.word_unselect_all_analysis(self, k)

    def select_all_analysis(self, k: 'int'=0) -> "void":
        return _freeling.word_select_all_analysis(self, k)

    def select_analysis(self, arg2: 'freeling::word::iterator', k: 'int'=0) -> "void":
        return _freeling.word_select_analysis(self, arg2, k)

    def unselect_analysis(self, arg2: 'freeling::word::iterator', k: 'int'=0) -> "void":
        return _freeling.word_unselect_analysis(self, arg2, k)

    def get_analysis(self) -> "std::list< freeling::analysis,std::allocator< freeling::analysis > >":
        return _freeling.word_get_analysis(self)

    def analysis_begin(self, *args) -> "freeling::word::const_iterator":
        return _freeling.word_analysis_begin(self, *args)

    def analysis_end(self, *args) -> "freeling::word::const_iterator":
        return _freeling.word_analysis_end(self, *args)
word_swigregister = _freeling.word_swigregister
word_swigregister(word)

class node(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, node, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, node, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_node(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_node
    __del__ = lambda self: None

    def get_node_id(self) -> "std::wstring":
        return _freeling.node_get_node_id(self)

    def set_node_id(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.node_set_node_id(self, arg2)

    def get_label(self) -> "std::wstring":
        return _freeling.node_get_label(self)

    def has_word(self) -> "bool":
        return _freeling.node_has_word(self)

    def get_word(self, *args) -> "freeling::word const &":
        return _freeling.node_get_word(self, *args)

    def set_label(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.node_set_label(self, arg2)

    def set_word(self, arg2: 'word') -> "void":
        return _freeling.node_set_word(self, arg2)

    def is_head(self) -> "bool":
        return _freeling.node_is_head(self)

    def set_head(self, arg2: 'bool const') -> "void":
        return _freeling.node_set_head(self, arg2)

    def is_chunk(self) -> "bool":
        return _freeling.node_is_chunk(self)

    def set_chunk(self, arg2: 'int const') -> "void":
        return _freeling.node_set_chunk(self, arg2)

    def get_chunk_ord(self) -> "int":
        return _freeling.node_get_chunk_ord(self)
node_swigregister = _freeling.node_swigregister
node_swigregister(node)

class parse_tree(TreeOfNode):
    __swig_setmethods__ = {}
    for _s in [TreeOfNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, parse_tree, name, value)
    __swig_getmethods__ = {}
    for _s in [TreeOfNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, parse_tree, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_parse_tree(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def build_node_index(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.parse_tree_build_node_index(self, arg2)

    def rebuild_node_index(self) -> "void":
        return _freeling.parse_tree_rebuild_node_index(self)

    def get_node_by_id(self, *args) -> "freeling::parse_tree::const_iterator":
        return _freeling.parse_tree_get_node_by_id(self, *args)

    def get_node_by_pos(self, *args) -> "freeling::parse_tree::const_iterator":
        return _freeling.parse_tree_get_node_by_pos(self, *args)
    __swig_getmethods__["get_head_word"] = lambda x: _freeling.parse_tree_get_head_word
    if _newclass:
        get_head_word = staticmethod(_freeling.parse_tree_get_head_word)
    __swig_getmethods__["get_head_position"] = lambda x: _freeling.parse_tree_get_head_position
    if _newclass:
        get_head_position = staticmethod(_freeling.parse_tree_get_head_position)
    __swig_getmethods__["C_commands"] = lambda x: _freeling.parse_tree_C_commands
    if _newclass:
        C_commands = staticmethod(_freeling.parse_tree_C_commands)

    def nth_child_ref(self, arg2: 'unsigned int') -> "freeling::parse_tree &":
        return _freeling.parse_tree_nth_child_ref(self, arg2)
    __swig_destroy__ = _freeling.delete_parse_tree
    __del__ = lambda self: None
parse_tree_swigregister = _freeling.parse_tree_swigregister
parse_tree_swigregister(parse_tree)

def parse_tree_get_head_word(arg2: 'TreeConstPreorderIteratorNode') -> "freeling::word const &":
    return _freeling.parse_tree_get_head_word(arg2)
parse_tree_get_head_word = _freeling.parse_tree_get_head_word

def parse_tree_get_head_position(pt: 'TreeConstPreorderIteratorNode') -> "int":
    return _freeling.parse_tree_get_head_position(pt)
parse_tree_get_head_position = _freeling.parse_tree_get_head_position

def parse_tree_C_commands(arg2: 'TreeConstPreorderIteratorNode', arg3: 'TreeConstPreorderIteratorNode') -> "bool":
    return _freeling.parse_tree_C_commands(arg2, arg3)
parse_tree_C_commands = _freeling.parse_tree_C_commands

class depnode(node):
    __swig_setmethods__ = {}
    for _s in [node]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, depnode, name, value)
    __swig_getmethods__ = {}
    for _s in [node]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, depnode, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_depnode(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_depnode
    __del__ = lambda self: None

    def set_link(self, arg2: 'TreePreorderIteratorNode') -> "void":
        return _freeling.depnode_set_link(self, arg2)

    def get_link(self, *args) -> "freeling::parse_tree::const_iterator":
        return _freeling.depnode_get_link(self, *args)
depnode_swigregister = _freeling.depnode_swigregister
depnode_swigregister(depnode)

class dep_tree(TreeOfDepnode):
    __swig_setmethods__ = {}
    for _s in [TreeOfDepnode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, dep_tree, name, value)
    __swig_getmethods__ = {}
    for _s in [TreeOfDepnode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, dep_tree, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_dep_tree(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_node_by_pos(self, *args) -> "freeling::dep_tree::const_iterator":
        return _freeling.dep_tree_get_node_by_pos(self, *args)

    def rebuild_node_index(self) -> "void":
        return _freeling.dep_tree_rebuild_node_index(self)
    __swig_getmethods__["get_first_word"] = lambda x: _freeling.dep_tree_get_first_word
    if _newclass:
        get_first_word = staticmethod(_freeling.dep_tree_get_first_word)
    __swig_getmethods__["get_last_word"] = lambda x: _freeling.dep_tree_get_last_word
    if _newclass:
        get_last_word = staticmethod(_freeling.dep_tree_get_last_word)

    def nth_child_ref(self, arg2: 'unsigned int') -> "freeling::dep_tree &":
        return _freeling.dep_tree_nth_child_ref(self, arg2)
    __swig_destroy__ = _freeling.delete_dep_tree
    __del__ = lambda self: None
dep_tree_swigregister = _freeling.dep_tree_swigregister
dep_tree_swigregister(dep_tree)

def dep_tree_get_first_word(arg2: 'TreeConstPreorderIteratorDepnode') -> "size_t":
    return _freeling.dep_tree_get_first_word(arg2)
dep_tree_get_first_word = _freeling.dep_tree_get_first_word

def dep_tree_get_last_word(arg2: 'TreeConstPreorderIteratorDepnode') -> "size_t":
    return _freeling.dep_tree_get_last_word(arg2)
dep_tree_get_last_word = _freeling.dep_tree_get_last_word

class argument(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, argument, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, argument, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _freeling.delete_argument
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _freeling.new_argument(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_position(self) -> "int":
        return _freeling.argument_get_position(self)

    def get_role(self) -> "std::wstring":
        return _freeling.argument_get_role(self)
argument_swigregister = _freeling.argument_swigregister
argument_swigregister(argument)
cvar = _freeling.cvar
argument.EMPTY_ROLE = _freeling.cvar.argument_EMPTY_ROLE

class predicate(VectorArgument):
    __swig_setmethods__ = {}
    for _s in [VectorArgument]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, predicate, name, value)
    __swig_getmethods__ = {}
    for _s in [VectorArgument]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, predicate, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _freeling.delete_predicate
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _freeling.new_predicate(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_sense(self) -> "std::wstring":
        return _freeling.predicate_get_sense(self)

    def get_position(self) -> "int":
        return _freeling.predicate_get_position(self)

    def has_argument(self, p: 'int') -> "bool":
        return _freeling.predicate_has_argument(self, p)

    def add_argument(self, p: 'int', r: 'std::wstring const &') -> "void":
        return _freeling.predicate_add_argument(self, p, r)

    def get_argument_by_pos(self, p: 'int') -> "freeling::argument const &":
        return _freeling.predicate_get_argument_by_pos(self, p)
predicate_swigregister = _freeling.predicate_swigregister
predicate_swigregister(predicate)

class sentence(ListWord):
    __swig_setmethods__ = {}
    for _s in [ListWord]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, sentence, name, value)
    __swig_getmethods__ = {}
    for _s in [ListWord]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, sentence, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_sentence(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_sentence
    __del__ = lambda self: None

    def num_kbest(self) -> "unsigned int":
        return _freeling.sentence_num_kbest(self)

    def push_back(self, arg2: 'word') -> "void":
        return _freeling.sentence_push_back(self, arg2)

    def rebuild_word_index(self) -> "void":
        return _freeling.sentence_rebuild_word_index(self)

    def clear(self) -> "void":
        return _freeling.sentence_clear(self)

    def set_sentence_id(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.sentence_set_sentence_id(self, arg2)

    def get_sentence_id(self) -> "std::wstring":
        return _freeling.sentence_get_sentence_id(self)

    def set_is_tagged(self, arg2: 'bool') -> "void":
        return _freeling.sentence_set_is_tagged(self, arg2)

    def is_tagged(self) -> "bool":
        return _freeling.sentence_is_tagged(self)

    def set_best_seq(self, k: 'int') -> "void":
        return _freeling.sentence_set_best_seq(self, k)

    def get_best_seq(self) -> "int":
        return _freeling.sentence_get_best_seq(self)

    def set_parse_tree(self, arg2: 'parse_tree', k: 'int'=0) -> "void":
        return _freeling.sentence_set_parse_tree(self, arg2, k)

    def get_parse_tree(self, *args) -> "freeling::parse_tree const &":
        return _freeling.sentence_get_parse_tree(self, *args)

    def is_parsed(self) -> "bool":
        return _freeling.sentence_is_parsed(self)

    def set_dep_tree(self, arg2: 'dep_tree', k: 'int'=0) -> "void":
        return _freeling.sentence_set_dep_tree(self, arg2, k)

    def get_dep_tree(self, *args) -> "freeling::dep_tree const &":
        return _freeling.sentence_get_dep_tree(self, *args)

    def is_dep_parsed(self) -> "bool":
        return _freeling.sentence_is_dep_parsed(self)

    def get_words(self) -> "std::vector< freeling::word,std::allocator< freeling::word > >":
        return _freeling.sentence_get_words(self)

    def words_begin(self, *args) -> "freeling::sentence::const_iterator":
        return _freeling.sentence_words_begin(self, *args)

    def words_end(self, *args) -> "freeling::sentence::const_iterator":
        return _freeling.sentence_words_end(self, *args)

    def get_word_iterator(self, *args) -> "freeling::sentence::iterator":
        return _freeling.sentence_get_word_iterator(self, *args)

    def add_predicate(self, pr: 'predicate') -> "void":
        return _freeling.sentence_add_predicate(self, pr)

    def is_predicate(self, p: 'int') -> "bool":
        return _freeling.sentence_is_predicate(self, p)

    def get_predicate_number(self, p: 'int') -> "int":
        return _freeling.sentence_get_predicate_number(self, p)

    def get_predicate_position(self, n: 'int') -> "int":
        return _freeling.sentence_get_predicate_position(self, n)

    def get_predicate_by_pos(self, n: 'int') -> "freeling::predicate const &":
        return _freeling.sentence_get_predicate_by_pos(self, n)

    def get_predicate_by_number(self, n: 'int') -> "freeling::predicate const &":
        return _freeling.sentence_get_predicate_by_number(self, n)

    def get_predicates(self) -> "freeling::sentence::predicates const &":
        return _freeling.sentence_get_predicates(self)
sentence_swigregister = _freeling.sentence_swigregister
sentence_swigregister(sentence)

class paragraph(ListSentence):
    __swig_setmethods__ = {}
    for _s in [ListSentence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, paragraph, name, value)
    __swig_getmethods__ = {}
    for _s in [ListSentence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, paragraph, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_paragraph(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def set_paragraph_id(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.paragraph_set_paragraph_id(self, arg2)

    def get_paragraph_id(self) -> "std::wstring":
        return _freeling.paragraph_get_paragraph_id(self)
    __swig_destroy__ = _freeling.delete_paragraph
    __del__ = lambda self: None
paragraph_swigregister = _freeling.paragraph_swigregister
paragraph_swigregister(paragraph)

class mention(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mention, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mention, name)
    __repr__ = _swig_repr
    PROPER_NOUN = _freeling.mention_PROPER_NOUN
    PRONOUN = _freeling.mention_PRONOUN
    NOUN_PHRASE = _freeling.mention_NOUN_PHRASE
    COMPOSITE = _freeling.mention_COMPOSITE
    VERB_PHRASE = _freeling.mention_VERB_PHRASE
    PER = _freeling.mention_PER
    MALE = _freeling.mention_MALE
    FEMALE = _freeling.mention_FEMALE
    NOTPER = _freeling.mention_NOTPER
    ORG = _freeling.mention_ORG
    GEO = _freeling.mention_GEO
    OTHER = _freeling.mention_OTHER

    def __init__(self, *args):
        this = _freeling.new_mention(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def __lt__(self, m: 'mention') -> "bool":
        return _freeling.mention___lt__(self, m)

    def set_id(self, arg2: 'int') -> "void":
        return _freeling.mention_set_id(self, arg2)

    def set_type(self, arg2: 'freeling::mention::mentionType') -> "void":
        return _freeling.mention_set_type(self, arg2)

    def set_initial(self, arg2: 'bool') -> "void":
        return _freeling.mention_set_initial(self, arg2)

    def set_group(self, arg2: 'int') -> "void":
        return _freeling.mention_set_group(self, arg2)

    def set_maximal(self, b: 'bool') -> "void":
        return _freeling.mention_set_maximal(self, b)

    def get_id(self) -> "int":
        return _freeling.mention_get_id(self)

    def get_n_sentence(self) -> "int":
        return _freeling.mention_get_n_sentence(self)

    def get_sentence(self) -> "freeling::paragraph::const_iterator":
        return _freeling.mention_get_sentence(self)

    def get_pos_begin(self) -> "int":
        return _freeling.mention_get_pos_begin(self)

    def get_pos_end(self) -> "int":
        return _freeling.mention_get_pos_end(self)

    def get_it_begin(self) -> "freeling::sentence::const_iterator":
        return _freeling.mention_get_it_begin(self)

    def get_it_end(self) -> "freeling::sentence::const_iterator":
        return _freeling.mention_get_it_end(self)

    def get_it_head(self) -> "freeling::sentence::const_iterator":
        return _freeling.mention_get_it_head(self)

    def get_type(self) -> "freeling::mention::mentionType":
        return _freeling.mention_get_type(self)

    def get_group(self) -> "int":
        return _freeling.mention_get_group(self)

    def is_type(self, arg2: 'freeling::mention::mentionType') -> "bool":
        return _freeling.mention_is_type(self, arg2)

    def is_initial(self) -> "bool":
        return _freeling.mention_is_initial(self)

    def is_maximal(self) -> "bool":
        return _freeling.mention_is_maximal(self)

    def get_ptree(self) -> "freeling::parse_tree::const_iterator":
        return _freeling.mention_get_ptree(self)

    def get_head(self) -> "freeling::word const &":
        return _freeling.mention_get_head(self)

    def value(self) -> "std::wstring":
        return _freeling.mention_value(self)
    __swig_destroy__ = _freeling.delete_mention
    __del__ = lambda self: None
mention_swigregister = _freeling.mention_swigregister
mention_swigregister(mention)

class SG_mention(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SG_mention, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SG_mention, name)
    __repr__ = _swig_repr

    def __init__(self, mid: 'std::wstring const &', sid: 'std::wstring const &', wds: 'ListString'):
        this = _freeling.new_SG_mention(mid, sid, wds)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_SG_mention
    __del__ = lambda self: None

    def get_id(self) -> "std::wstring":
        return _freeling.SG_mention_get_id(self)

    def get_sentence_id(self) -> "std::wstring":
        return _freeling.SG_mention_get_sentence_id(self)

    def get_words(self) -> "std::list< std::wstring,std::allocator< std::wstring > > const &":
        return _freeling.SG_mention_get_words(self)
SG_mention_swigregister = _freeling.SG_mention_swigregister
SG_mention_swigregister(SG_mention)


_freeling.ENTITY_swigconstant(_freeling)
ENTITY = _freeling.ENTITY

_freeling.WORD_swigconstant(_freeling)
WORD = _freeling.WORD
class SG_entity(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SG_entity, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SG_entity, name)
    __repr__ = _swig_repr

    def __init__(self, elemma: 'std::wstring const &', eclass: 'std::wstring const &', type: 'freeling::semgraph::entityType', sense: 'std::wstring const &'):
        this = _freeling.new_SG_entity(elemma, eclass, type, sense)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_SG_entity
    __del__ = lambda self: None

    def set_lemma(self, lem: 'std::wstring const &') -> "void":
        return _freeling.SG_entity_set_lemma(self, lem)

    def get_id(self) -> "std::wstring":
        return _freeling.SG_entity_get_id(self)

    def get_lemma(self) -> "std::wstring":
        return _freeling.SG_entity_get_lemma(self)

    def get_semclass(self) -> "std::wstring":
        return _freeling.SG_entity_get_semclass(self)

    def get_type(self) -> "freeling::semgraph::entityType":
        return _freeling.SG_entity_get_type(self)

    def get_sense(self) -> "std::wstring":
        return _freeling.SG_entity_get_sense(self)

    def get_mentions(self) -> "std::vector< freeling::semgraph::SG_mention,std::allocator< freeling::semgraph::SG_mention > > const &":
        return _freeling.SG_entity_get_mentions(self)
SG_entity_swigregister = _freeling.SG_entity_swigregister
SG_entity_swigregister(SG_entity)

class SG_argument(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SG_argument, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SG_argument, name)
    __repr__ = _swig_repr

    def __init__(self, r: 'std::wstring const &', e: 'std::wstring const &'):
        this = _freeling.new_SG_argument(r, e)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_SG_argument
    __del__ = lambda self: None

    def get_role(self) -> "std::wstring":
        return _freeling.SG_argument_get_role(self)

    def get_entity(self) -> "std::wstring":
        return _freeling.SG_argument_get_entity(self)
SG_argument_swigregister = _freeling.SG_argument_swigregister
SG_argument_swigregister(SG_argument)

class SG_frame(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SG_frame, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SG_frame, name)
    __repr__ = _swig_repr

    def __init__(self, lem: 'std::wstring const &', sns: 'std::wstring const &', tk: 'std::wstring const &', sid: 'std::wstring const &'):
        this = _freeling.new_SG_frame(lem, sns, tk, sid)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_SG_frame
    __del__ = lambda self: None

    def get_id(self) -> "std::wstring":
        return _freeling.SG_frame_get_id(self)

    def get_lemma(self) -> "std::wstring":
        return _freeling.SG_frame_get_lemma(self)

    def get_sense(self) -> "std::wstring":
        return _freeling.SG_frame_get_sense(self)

    def get_token_id(self) -> "std::wstring":
        return _freeling.SG_frame_get_token_id(self)

    def get_sentence_id(self) -> "std::wstring":
        return _freeling.SG_frame_get_sentence_id(self)

    def get_arguments(self) -> "std::vector< freeling::semgraph::SG_argument,std::allocator< freeling::semgraph::SG_argument > > const &":
        return _freeling.SG_frame_get_arguments(self)
SG_frame_swigregister = _freeling.SG_frame_swigregister
SG_frame_swigregister(SG_frame)

class semantic_graph(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, semantic_graph, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, semantic_graph, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _freeling.new_semantic_graph()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_semantic_graph
    __del__ = lambda self: None

    def add_entity(self, ent: 'SG_entity') -> "std::wstring":
        return _freeling.semantic_graph_add_entity(self, ent)

    def add_frame(self, fr: 'SG_frame') -> "std::wstring":
        return _freeling.semantic_graph_add_frame(self, fr)

    def get_frame(self, *args) -> "freeling::semgraph::SG_frame &":
        return _freeling.semantic_graph_get_frame(self, *args)

    def get_entity_id_by_mention(self, sid: 'std::wstring const &', wid: 'std::wstring const &') -> "std::wstring":
        return _freeling.semantic_graph_get_entity_id_by_mention(self, sid, wid)

    def get_entity_id_by_lemma(self, lemma: 'std::wstring const &', sens: 'std::wstring const &') -> "std::wstring":
        return _freeling.semantic_graph_get_entity_id_by_lemma(self, lemma, sens)

    def get_entity(self, *args) -> "freeling::semgraph::SG_entity &":
        return _freeling.semantic_graph_get_entity(self, *args)

    def get_entities(self, *args) -> "std::vector< freeling::semgraph::SG_entity,std::allocator< freeling::semgraph::SG_entity > > &":
        return _freeling.semantic_graph_get_entities(self, *args)

    def get_frames(self, *args) -> "std::vector< freeling::semgraph::SG_frame,std::allocator< freeling::semgraph::SG_frame > > &":
        return _freeling.semantic_graph_get_frames(self, *args)

    def add_mention_to_entity(self, eid: 'std::wstring const &', m: 'SG_mention') -> "void":
        return _freeling.semantic_graph_add_mention_to_entity(self, eid, m)

    def add_argument_to_frame(self, fid: 'std::wstring const &', role: 'std::wstring const &', eid: 'std::wstring const &') -> "void":
        return _freeling.semantic_graph_add_argument_to_frame(self, fid, role, eid)

    def is_argument(self, eid: 'std::wstring const &') -> "bool":
        return _freeling.semantic_graph_is_argument(self, eid)

    def has_arguments(self, fid: 'std::wstring const &') -> "bool":
        return _freeling.semantic_graph_has_arguments(self, fid)

    def empty(self) -> "bool":
        return _freeling.semantic_graph_empty(self)
semantic_graph_swigregister = _freeling.semantic_graph_swigregister
semantic_graph_swigregister(semantic_graph)

class document(ListParagraph):
    __swig_setmethods__ = {}
    for _s in [ListParagraph]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, document, name, value)
    __swig_getmethods__ = {}
    for _s in [ListParagraph]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, document, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_document(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def is_parsed(self) -> "bool":
        return _freeling.document_is_parsed(self)

    def is_dep_parsed(self) -> "bool":
        return _freeling.document_is_dep_parsed(self)

    def add_mention(self, m: 'mention') -> "void":
        return _freeling.document_add_mention(self, m)

    def get_num_words(self) -> "int":
        return _freeling.document_get_num_words(self)

    def get_num_groups(self) -> "int":
        return _freeling.document_get_num_groups(self)

    def get_groups(self) -> "std::list< int,std::allocator< int > > const &":
        return _freeling.document_get_groups(self)

    def begin_mentions(self, *args) -> "std::vector< freeling::mention,std::allocator< freeling::mention > >::const_iterator":
        return _freeling.document_begin_mentions(self, *args)

    def end_mentions(self, *args) -> "std::vector< freeling::mention,std::allocator< freeling::mention > >::const_iterator":
        return _freeling.document_end_mentions(self, *args)

    def get_semantic_graph(self, *args) -> "freeling::semgraph::semantic_graph &":
        return _freeling.document_get_semantic_graph(self, *args)

    def get_mention(self, arg2: 'int') -> "freeling::mention const &":
        return _freeling.document_get_mention(self, arg2)

    def get_coref_id_mentions(self, arg2: 'int') -> "std::list< int,std::allocator< int > >":
        return _freeling.document_get_coref_id_mentions(self, arg2)
    __swig_destroy__ = _freeling.delete_document
    __del__ = lambda self: None
document_swigregister = _freeling.document_swigregister
document_swigregister(document)


_freeling.TEXT_swigconstant(_freeling)
TEXT = _freeling.TEXT

_freeling.IDENT_swigconstant(_freeling)
IDENT = _freeling.IDENT

_freeling.TOKEN_swigconstant(_freeling)
TOKEN = _freeling.TOKEN

_freeling.SPLITTED_swigconstant(_freeling)
SPLITTED = _freeling.SPLITTED

_freeling.MORFO_swigconstant(_freeling)
MORFO = _freeling.MORFO

_freeling.TAGGED_swigconstant(_freeling)
TAGGED = _freeling.TAGGED

_freeling.SENSES_swigconstant(_freeling)
SENSES = _freeling.SENSES

_freeling.SHALLOW_swigconstant(_freeling)
SHALLOW = _freeling.SHALLOW

_freeling.PARSED_swigconstant(_freeling)
PARSED = _freeling.PARSED

_freeling.DEP_swigconstant(_freeling)
DEP = _freeling.DEP

_freeling.COREF_swigconstant(_freeling)
COREF = _freeling.COREF

_freeling.SEMGRAPH_swigconstant(_freeling)
SEMGRAPH = _freeling.SEMGRAPH

_freeling.NO_TAGGER_swigconstant(_freeling)
NO_TAGGER = _freeling.NO_TAGGER

_freeling.HMM_swigconstant(_freeling)
HMM = _freeling.HMM

_freeling.RELAX_swigconstant(_freeling)
RELAX = _freeling.RELAX

_freeling.NO_DEP_swigconstant(_freeling)
NO_DEP = _freeling.NO_DEP

_freeling.TXALA_swigconstant(_freeling)
TXALA = _freeling.TXALA

_freeling.TREELER_swigconstant(_freeling)
TREELER = _freeling.TREELER

_freeling.NO_WSD_swigconstant(_freeling)
NO_WSD = _freeling.NO_WSD

_freeling.ALL_swigconstant(_freeling)
ALL = _freeling.ALL

_freeling.MFS_swigconstant(_freeling)
MFS = _freeling.MFS

_freeling.UKB_swigconstant(_freeling)
UKB = _freeling.UKB

_freeling.NO_FORCE_swigconstant(_freeling)
NO_FORCE = _freeling.NO_FORCE

_freeling.TAGGER_swigconstant(_freeling)
TAGGER = _freeling.TAGGER

_freeling.RETOK_swigconstant(_freeling)
RETOK = _freeling.RETOK
class config_options(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, config_options, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, config_options, name)
    __repr__ = _swig_repr
    __swig_setmethods__["Lang"] = _freeling.config_options_Lang_set
    __swig_getmethods__["Lang"] = _freeling.config_options_Lang_get
    if _newclass:
        Lang = _swig_property(_freeling.config_options_Lang_get, _freeling.config_options_Lang_set)
    __swig_setmethods__["TOK_TokenizerFile"] = _freeling.config_options_TOK_TokenizerFile_set
    __swig_getmethods__["TOK_TokenizerFile"] = _freeling.config_options_TOK_TokenizerFile_get
    if _newclass:
        TOK_TokenizerFile = _swig_property(_freeling.config_options_TOK_TokenizerFile_get, _freeling.config_options_TOK_TokenizerFile_set)
    __swig_setmethods__["SPLIT_SplitterFile"] = _freeling.config_options_SPLIT_SplitterFile_set
    __swig_getmethods__["SPLIT_SplitterFile"] = _freeling.config_options_SPLIT_SplitterFile_get
    if _newclass:
        SPLIT_SplitterFile = _swig_property(_freeling.config_options_SPLIT_SplitterFile_get, _freeling.config_options_SPLIT_SplitterFile_set)
    __swig_setmethods__["MACO_Decimal"] = _freeling.config_options_MACO_Decimal_set
    __swig_getmethods__["MACO_Decimal"] = _freeling.config_options_MACO_Decimal_get
    if _newclass:
        MACO_Decimal = _swig_property(_freeling.config_options_MACO_Decimal_get, _freeling.config_options_MACO_Decimal_set)
    __swig_setmethods__["MACO_Thousand"] = _freeling.config_options_MACO_Thousand_set
    __swig_getmethods__["MACO_Thousand"] = _freeling.config_options_MACO_Thousand_get
    if _newclass:
        MACO_Thousand = _swig_property(_freeling.config_options_MACO_Thousand_get, _freeling.config_options_MACO_Thousand_set)
    __swig_setmethods__["MACO_UserMapFile"] = _freeling.config_options_MACO_UserMapFile_set
    __swig_getmethods__["MACO_UserMapFile"] = _freeling.config_options_MACO_UserMapFile_get
    if _newclass:
        MACO_UserMapFile = _swig_property(_freeling.config_options_MACO_UserMapFile_get, _freeling.config_options_MACO_UserMapFile_set)
    __swig_setmethods__["MACO_LocutionsFile"] = _freeling.config_options_MACO_LocutionsFile_set
    __swig_getmethods__["MACO_LocutionsFile"] = _freeling.config_options_MACO_LocutionsFile_get
    if _newclass:
        MACO_LocutionsFile = _swig_property(_freeling.config_options_MACO_LocutionsFile_get, _freeling.config_options_MACO_LocutionsFile_set)
    __swig_setmethods__["MACO_QuantitiesFile"] = _freeling.config_options_MACO_QuantitiesFile_set
    __swig_getmethods__["MACO_QuantitiesFile"] = _freeling.config_options_MACO_QuantitiesFile_get
    if _newclass:
        MACO_QuantitiesFile = _swig_property(_freeling.config_options_MACO_QuantitiesFile_get, _freeling.config_options_MACO_QuantitiesFile_set)
    __swig_setmethods__["MACO_AffixFile"] = _freeling.config_options_MACO_AffixFile_set
    __swig_getmethods__["MACO_AffixFile"] = _freeling.config_options_MACO_AffixFile_get
    if _newclass:
        MACO_AffixFile = _swig_property(_freeling.config_options_MACO_AffixFile_get, _freeling.config_options_MACO_AffixFile_set)
    __swig_setmethods__["MACO_ProbabilityFile"] = _freeling.config_options_MACO_ProbabilityFile_set
    __swig_getmethods__["MACO_ProbabilityFile"] = _freeling.config_options_MACO_ProbabilityFile_get
    if _newclass:
        MACO_ProbabilityFile = _swig_property(_freeling.config_options_MACO_ProbabilityFile_get, _freeling.config_options_MACO_ProbabilityFile_set)
    __swig_setmethods__["MACO_DictionaryFile"] = _freeling.config_options_MACO_DictionaryFile_set
    __swig_getmethods__["MACO_DictionaryFile"] = _freeling.config_options_MACO_DictionaryFile_get
    if _newclass:
        MACO_DictionaryFile = _swig_property(_freeling.config_options_MACO_DictionaryFile_get, _freeling.config_options_MACO_DictionaryFile_set)
    __swig_setmethods__["MACO_NPDataFile"] = _freeling.config_options_MACO_NPDataFile_set
    __swig_getmethods__["MACO_NPDataFile"] = _freeling.config_options_MACO_NPDataFile_get
    if _newclass:
        MACO_NPDataFile = _swig_property(_freeling.config_options_MACO_NPDataFile_get, _freeling.config_options_MACO_NPDataFile_set)
    __swig_setmethods__["MACO_PunctuationFile"] = _freeling.config_options_MACO_PunctuationFile_set
    __swig_getmethods__["MACO_PunctuationFile"] = _freeling.config_options_MACO_PunctuationFile_get
    if _newclass:
        MACO_PunctuationFile = _swig_property(_freeling.config_options_MACO_PunctuationFile_get, _freeling.config_options_MACO_PunctuationFile_set)
    __swig_setmethods__["MACO_CompoundFile"] = _freeling.config_options_MACO_CompoundFile_set
    __swig_getmethods__["MACO_CompoundFile"] = _freeling.config_options_MACO_CompoundFile_get
    if _newclass:
        MACO_CompoundFile = _swig_property(_freeling.config_options_MACO_CompoundFile_get, _freeling.config_options_MACO_CompoundFile_set)
    __swig_setmethods__["MACO_ProbabilityThreshold"] = _freeling.config_options_MACO_ProbabilityThreshold_set
    __swig_getmethods__["MACO_ProbabilityThreshold"] = _freeling.config_options_MACO_ProbabilityThreshold_get
    if _newclass:
        MACO_ProbabilityThreshold = _swig_property(_freeling.config_options_MACO_ProbabilityThreshold_get, _freeling.config_options_MACO_ProbabilityThreshold_set)
    __swig_setmethods__["PHON_PhoneticsFile"] = _freeling.config_options_PHON_PhoneticsFile_set
    __swig_getmethods__["PHON_PhoneticsFile"] = _freeling.config_options_PHON_PhoneticsFile_get
    if _newclass:
        PHON_PhoneticsFile = _swig_property(_freeling.config_options_PHON_PhoneticsFile_get, _freeling.config_options_PHON_PhoneticsFile_set)
    __swig_setmethods__["NEC_NECFile"] = _freeling.config_options_NEC_NECFile_set
    __swig_getmethods__["NEC_NECFile"] = _freeling.config_options_NEC_NECFile_get
    if _newclass:
        NEC_NECFile = _swig_property(_freeling.config_options_NEC_NECFile_get, _freeling.config_options_NEC_NECFile_set)
    __swig_setmethods__["SENSE_ConfigFile"] = _freeling.config_options_SENSE_ConfigFile_set
    __swig_getmethods__["SENSE_ConfigFile"] = _freeling.config_options_SENSE_ConfigFile_get
    if _newclass:
        SENSE_ConfigFile = _swig_property(_freeling.config_options_SENSE_ConfigFile_get, _freeling.config_options_SENSE_ConfigFile_set)
    __swig_setmethods__["UKB_ConfigFile"] = _freeling.config_options_UKB_ConfigFile_set
    __swig_getmethods__["UKB_ConfigFile"] = _freeling.config_options_UKB_ConfigFile_get
    if _newclass:
        UKB_ConfigFile = _swig_property(_freeling.config_options_UKB_ConfigFile_get, _freeling.config_options_UKB_ConfigFile_set)
    __swig_setmethods__["TAGGER_HMMFile"] = _freeling.config_options_TAGGER_HMMFile_set
    __swig_getmethods__["TAGGER_HMMFile"] = _freeling.config_options_TAGGER_HMMFile_get
    if _newclass:
        TAGGER_HMMFile = _swig_property(_freeling.config_options_TAGGER_HMMFile_get, _freeling.config_options_TAGGER_HMMFile_set)
    __swig_setmethods__["TAGGER_RelaxFile"] = _freeling.config_options_TAGGER_RelaxFile_set
    __swig_getmethods__["TAGGER_RelaxFile"] = _freeling.config_options_TAGGER_RelaxFile_get
    if _newclass:
        TAGGER_RelaxFile = _swig_property(_freeling.config_options_TAGGER_RelaxFile_get, _freeling.config_options_TAGGER_RelaxFile_set)
    __swig_setmethods__["TAGGER_RelaxMaxIter"] = _freeling.config_options_TAGGER_RelaxMaxIter_set
    __swig_getmethods__["TAGGER_RelaxMaxIter"] = _freeling.config_options_TAGGER_RelaxMaxIter_get
    if _newclass:
        TAGGER_RelaxMaxIter = _swig_property(_freeling.config_options_TAGGER_RelaxMaxIter_get, _freeling.config_options_TAGGER_RelaxMaxIter_set)
    __swig_setmethods__["TAGGER_RelaxScaleFactor"] = _freeling.config_options_TAGGER_RelaxScaleFactor_set
    __swig_getmethods__["TAGGER_RelaxScaleFactor"] = _freeling.config_options_TAGGER_RelaxScaleFactor_get
    if _newclass:
        TAGGER_RelaxScaleFactor = _swig_property(_freeling.config_options_TAGGER_RelaxScaleFactor_get, _freeling.config_options_TAGGER_RelaxScaleFactor_set)
    __swig_setmethods__["TAGGER_RelaxEpsilon"] = _freeling.config_options_TAGGER_RelaxEpsilon_set
    __swig_getmethods__["TAGGER_RelaxEpsilon"] = _freeling.config_options_TAGGER_RelaxEpsilon_get
    if _newclass:
        TAGGER_RelaxEpsilon = _swig_property(_freeling.config_options_TAGGER_RelaxEpsilon_get, _freeling.config_options_TAGGER_RelaxEpsilon_set)
    __swig_setmethods__["TAGGER_Retokenize"] = _freeling.config_options_TAGGER_Retokenize_set
    __swig_getmethods__["TAGGER_Retokenize"] = _freeling.config_options_TAGGER_Retokenize_get
    if _newclass:
        TAGGER_Retokenize = _swig_property(_freeling.config_options_TAGGER_Retokenize_get, _freeling.config_options_TAGGER_Retokenize_set)
    __swig_setmethods__["TAGGER_ForceSelect"] = _freeling.config_options_TAGGER_ForceSelect_set
    __swig_getmethods__["TAGGER_ForceSelect"] = _freeling.config_options_TAGGER_ForceSelect_get
    if _newclass:
        TAGGER_ForceSelect = _swig_property(_freeling.config_options_TAGGER_ForceSelect_get, _freeling.config_options_TAGGER_ForceSelect_set)
    __swig_setmethods__["PARSER_GrammarFile"] = _freeling.config_options_PARSER_GrammarFile_set
    __swig_getmethods__["PARSER_GrammarFile"] = _freeling.config_options_PARSER_GrammarFile_get
    if _newclass:
        PARSER_GrammarFile = _swig_property(_freeling.config_options_PARSER_GrammarFile_get, _freeling.config_options_PARSER_GrammarFile_set)
    __swig_setmethods__["DEP_TxalaFile"] = _freeling.config_options_DEP_TxalaFile_set
    __swig_getmethods__["DEP_TxalaFile"] = _freeling.config_options_DEP_TxalaFile_get
    if _newclass:
        DEP_TxalaFile = _swig_property(_freeling.config_options_DEP_TxalaFile_get, _freeling.config_options_DEP_TxalaFile_set)
    __swig_setmethods__["DEP_TreelerFile"] = _freeling.config_options_DEP_TreelerFile_set
    __swig_getmethods__["DEP_TreelerFile"] = _freeling.config_options_DEP_TreelerFile_get
    if _newclass:
        DEP_TreelerFile = _swig_property(_freeling.config_options_DEP_TreelerFile_get, _freeling.config_options_DEP_TreelerFile_set)
    __swig_setmethods__["COREF_CorefFile"] = _freeling.config_options_COREF_CorefFile_set
    __swig_getmethods__["COREF_CorefFile"] = _freeling.config_options_COREF_CorefFile_get
    if _newclass:
        COREF_CorefFile = _swig_property(_freeling.config_options_COREF_CorefFile_get, _freeling.config_options_COREF_CorefFile_set)
    __swig_setmethods__["SEMGRAPH_SemGraphFile"] = _freeling.config_options_SEMGRAPH_SemGraphFile_set
    __swig_getmethods__["SEMGRAPH_SemGraphFile"] = _freeling.config_options_SEMGRAPH_SemGraphFile_get
    if _newclass:
        SEMGRAPH_SemGraphFile = _swig_property(_freeling.config_options_SEMGRAPH_SemGraphFile_get, _freeling.config_options_SEMGRAPH_SemGraphFile_set)

    def __init__(self):
        this = _freeling.new_config_options()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_config_options
    __del__ = lambda self: None
config_options_swigregister = _freeling.config_options_swigregister
config_options_swigregister(config_options)

class invoke_options(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, invoke_options, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, invoke_options, name)
    __repr__ = _swig_repr
    __swig_setmethods__["InputLevel"] = _freeling.invoke_options_InputLevel_set
    __swig_getmethods__["InputLevel"] = _freeling.invoke_options_InputLevel_get
    if _newclass:
        InputLevel = _swig_property(_freeling.invoke_options_InputLevel_get, _freeling.invoke_options_InputLevel_set)
    __swig_setmethods__["OutputLevel"] = _freeling.invoke_options_OutputLevel_set
    __swig_getmethods__["OutputLevel"] = _freeling.invoke_options_OutputLevel_get
    if _newclass:
        OutputLevel = _swig_property(_freeling.invoke_options_OutputLevel_get, _freeling.invoke_options_OutputLevel_set)
    __swig_setmethods__["MACO_UserMap"] = _freeling.invoke_options_MACO_UserMap_set
    __swig_getmethods__["MACO_UserMap"] = _freeling.invoke_options_MACO_UserMap_get
    if _newclass:
        MACO_UserMap = _swig_property(_freeling.invoke_options_MACO_UserMap_get, _freeling.invoke_options_MACO_UserMap_set)
    __swig_setmethods__["MACO_AffixAnalysis"] = _freeling.invoke_options_MACO_AffixAnalysis_set
    __swig_getmethods__["MACO_AffixAnalysis"] = _freeling.invoke_options_MACO_AffixAnalysis_get
    if _newclass:
        MACO_AffixAnalysis = _swig_property(_freeling.invoke_options_MACO_AffixAnalysis_get, _freeling.invoke_options_MACO_AffixAnalysis_set)
    __swig_setmethods__["MACO_MultiwordsDetection"] = _freeling.invoke_options_MACO_MultiwordsDetection_set
    __swig_getmethods__["MACO_MultiwordsDetection"] = _freeling.invoke_options_MACO_MultiwordsDetection_get
    if _newclass:
        MACO_MultiwordsDetection = _swig_property(_freeling.invoke_options_MACO_MultiwordsDetection_get, _freeling.invoke_options_MACO_MultiwordsDetection_set)
    __swig_setmethods__["MACO_NumbersDetection"] = _freeling.invoke_options_MACO_NumbersDetection_set
    __swig_getmethods__["MACO_NumbersDetection"] = _freeling.invoke_options_MACO_NumbersDetection_get
    if _newclass:
        MACO_NumbersDetection = _swig_property(_freeling.invoke_options_MACO_NumbersDetection_get, _freeling.invoke_options_MACO_NumbersDetection_set)
    __swig_setmethods__["MACO_PunctuationDetection"] = _freeling.invoke_options_MACO_PunctuationDetection_set
    __swig_getmethods__["MACO_PunctuationDetection"] = _freeling.invoke_options_MACO_PunctuationDetection_get
    if _newclass:
        MACO_PunctuationDetection = _swig_property(_freeling.invoke_options_MACO_PunctuationDetection_get, _freeling.invoke_options_MACO_PunctuationDetection_set)
    __swig_setmethods__["MACO_DatesDetection"] = _freeling.invoke_options_MACO_DatesDetection_set
    __swig_getmethods__["MACO_DatesDetection"] = _freeling.invoke_options_MACO_DatesDetection_get
    if _newclass:
        MACO_DatesDetection = _swig_property(_freeling.invoke_options_MACO_DatesDetection_get, _freeling.invoke_options_MACO_DatesDetection_set)
    __swig_setmethods__["MACO_QuantitiesDetection"] = _freeling.invoke_options_MACO_QuantitiesDetection_set
    __swig_getmethods__["MACO_QuantitiesDetection"] = _freeling.invoke_options_MACO_QuantitiesDetection_get
    if _newclass:
        MACO_QuantitiesDetection = _swig_property(_freeling.invoke_options_MACO_QuantitiesDetection_get, _freeling.invoke_options_MACO_QuantitiesDetection_set)
    __swig_setmethods__["MACO_DictionarySearch"] = _freeling.invoke_options_MACO_DictionarySearch_set
    __swig_getmethods__["MACO_DictionarySearch"] = _freeling.invoke_options_MACO_DictionarySearch_get
    if _newclass:
        MACO_DictionarySearch = _swig_property(_freeling.invoke_options_MACO_DictionarySearch_get, _freeling.invoke_options_MACO_DictionarySearch_set)
    __swig_setmethods__["MACO_ProbabilityAssignment"] = _freeling.invoke_options_MACO_ProbabilityAssignment_set
    __swig_getmethods__["MACO_ProbabilityAssignment"] = _freeling.invoke_options_MACO_ProbabilityAssignment_get
    if _newclass:
        MACO_ProbabilityAssignment = _swig_property(_freeling.invoke_options_MACO_ProbabilityAssignment_get, _freeling.invoke_options_MACO_ProbabilityAssignment_set)
    __swig_setmethods__["MACO_CompoundAnalysis"] = _freeling.invoke_options_MACO_CompoundAnalysis_set
    __swig_getmethods__["MACO_CompoundAnalysis"] = _freeling.invoke_options_MACO_CompoundAnalysis_get
    if _newclass:
        MACO_CompoundAnalysis = _swig_property(_freeling.invoke_options_MACO_CompoundAnalysis_get, _freeling.invoke_options_MACO_CompoundAnalysis_set)
    __swig_setmethods__["MACO_NERecognition"] = _freeling.invoke_options_MACO_NERecognition_set
    __swig_getmethods__["MACO_NERecognition"] = _freeling.invoke_options_MACO_NERecognition_get
    if _newclass:
        MACO_NERecognition = _swig_property(_freeling.invoke_options_MACO_NERecognition_get, _freeling.invoke_options_MACO_NERecognition_set)
    __swig_setmethods__["MACO_RetokContractions"] = _freeling.invoke_options_MACO_RetokContractions_set
    __swig_getmethods__["MACO_RetokContractions"] = _freeling.invoke_options_MACO_RetokContractions_get
    if _newclass:
        MACO_RetokContractions = _swig_property(_freeling.invoke_options_MACO_RetokContractions_get, _freeling.invoke_options_MACO_RetokContractions_set)
    __swig_setmethods__["PHON_Phonetics"] = _freeling.invoke_options_PHON_Phonetics_set
    __swig_getmethods__["PHON_Phonetics"] = _freeling.invoke_options_PHON_Phonetics_get
    if _newclass:
        PHON_Phonetics = _swig_property(_freeling.invoke_options_PHON_Phonetics_get, _freeling.invoke_options_PHON_Phonetics_set)
    __swig_setmethods__["NEC_NEClassification"] = _freeling.invoke_options_NEC_NEClassification_set
    __swig_getmethods__["NEC_NEClassification"] = _freeling.invoke_options_NEC_NEClassification_get
    if _newclass:
        NEC_NEClassification = _swig_property(_freeling.invoke_options_NEC_NEClassification_get, _freeling.invoke_options_NEC_NEClassification_set)
    __swig_setmethods__["SENSE_WSD_which"] = _freeling.invoke_options_SENSE_WSD_which_set
    __swig_getmethods__["SENSE_WSD_which"] = _freeling.invoke_options_SENSE_WSD_which_get
    if _newclass:
        SENSE_WSD_which = _swig_property(_freeling.invoke_options_SENSE_WSD_which_get, _freeling.invoke_options_SENSE_WSD_which_set)
    __swig_setmethods__["TAGGER_which"] = _freeling.invoke_options_TAGGER_which_set
    __swig_getmethods__["TAGGER_which"] = _freeling.invoke_options_TAGGER_which_get
    if _newclass:
        TAGGER_which = _swig_property(_freeling.invoke_options_TAGGER_which_get, _freeling.invoke_options_TAGGER_which_set)
    __swig_setmethods__["DEP_which"] = _freeling.invoke_options_DEP_which_set
    __swig_getmethods__["DEP_which"] = _freeling.invoke_options_DEP_which_get
    if _newclass:
        DEP_which = _swig_property(_freeling.invoke_options_DEP_which_get, _freeling.invoke_options_DEP_which_set)

    def __init__(self):
        this = _freeling.new_invoke_options()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_invoke_options
    __del__ = lambda self: None
invoke_options_swigregister = _freeling.invoke_options_swigregister
invoke_options_swigregister(invoke_options)

class analyzer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, analyzer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, analyzer, name)
    __repr__ = _swig_repr

    def __init__(self, cfg: 'config_options'):
        this = _freeling.new_analyzer(cfg)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def set_current_invoke_options(self, opt: 'invoke_options', check: 'bool'=True) -> "void":
        return _freeling.analyzer_set_current_invoke_options(self, opt, check)

    def get_current_invoke_options(self) -> "freeling::analyzer::invoke_options const &":
        return _freeling.analyzer_get_current_invoke_options(self)
    __swig_destroy__ = _freeling.delete_analyzer
    __del__ = lambda self: None

    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >":
        return _freeling.analyzer_analyze(self, *args)

    def analyze_as_document(self, text: 'std::wstring const &', parag: 'bool'=False) -> "freeling::document":
        return _freeling.analyzer_analyze_as_document(self, text, parag)

    def flush_buffer(self, ls: 'ListSentence') -> "void":
        return _freeling.analyzer_flush_buffer(self, ls)

    def reset_offset(self) -> "void":
        return _freeling.analyzer_reset_offset(self)
analyzer_swigregister = _freeling.analyzer_swigregister
analyzer_swigregister(analyzer)

class traces(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, traces, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, traces, name)
    __repr__ = _swig_repr
    __swig_setmethods__["TraceLevel"] = _freeling.traces_TraceLevel_set
    __swig_getmethods__["TraceLevel"] = _freeling.traces_TraceLevel_get
    if _newclass:
        TraceLevel = _swig_property(_freeling.traces_TraceLevel_get, _freeling.traces_TraceLevel_set)
    __swig_setmethods__["TraceModule"] = _freeling.traces_TraceModule_set
    __swig_getmethods__["TraceModule"] = _freeling.traces_TraceModule_get
    if _newclass:
        TraceModule = _swig_property(_freeling.traces_TraceModule_get, _freeling.traces_TraceModule_set)

    def __init__(self):
        this = _freeling.new_traces()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_traces
    __del__ = lambda self: None
traces_swigregister = _freeling.traces_swigregister
traces_swigregister(traces)

class lang_ident(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, lang_ident, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, lang_ident, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_lang_ident(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_lang_ident
    __del__ = lambda self: None

    def add_language(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.lang_ident_add_language(self, arg2)

    def train_language(self, arg2: 'std::wstring const &', arg3: 'std::wstring const &', arg4: 'std::wstring const &', order: 'size_t') -> "void":
        return _freeling.lang_ident_train_language(self, arg2, arg3, arg4, order)

    def identify_language(self, *args) -> "std::wstring":
        return _freeling.lang_ident_identify_language(self, *args)

    def rank_languages(self, *args) -> "std::vector< std::pair< double,std::wstring >,std::allocator< std::pair< double,std::wstring > > >":
        return _freeling.lang_ident_rank_languages(self, *args)
lang_ident_swigregister = _freeling.lang_ident_swigregister
lang_ident_swigregister(lang_ident)

class tokenizer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, tokenizer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, tokenizer, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &'):
        this = _freeling.new_tokenizer(arg2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_tokenizer
    __del__ = lambda self: None

    def tokenize(self, *args) -> "void":
        return _freeling.tokenizer_tokenize(self, *args)
tokenizer_swigregister = _freeling.tokenizer_swigregister
tokenizer_swigregister(tokenizer)

class splitter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, splitter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, splitter, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &'):
        this = _freeling.new_splitter(arg2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_splitter
    __del__ = lambda self: None

    def open_session(self) -> "freeling::splitter::session_id":
        return _freeling.splitter_open_session(self)

    def close_session(self, arg2: 'freeling::splitter::session_id') -> "void":
        return _freeling.splitter_close_session(self, arg2)

    def split(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >":
        return _freeling.splitter_split(self, *args)
splitter_swigregister = _freeling.splitter_swigregister
splitter_swigregister(splitter)

class maco_options(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, maco_options, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, maco_options, name)
    __repr__ = _swig_repr
    __swig_setmethods__["Lang"] = _freeling.maco_options_Lang_set
    __swig_getmethods__["Lang"] = _freeling.maco_options_Lang_get
    if _newclass:
        Lang = _swig_property(_freeling.maco_options_Lang_get, _freeling.maco_options_Lang_set)
    __swig_setmethods__["LocutionsFile"] = _freeling.maco_options_LocutionsFile_set
    __swig_getmethods__["LocutionsFile"] = _freeling.maco_options_LocutionsFile_get
    if _newclass:
        LocutionsFile = _swig_property(_freeling.maco_options_LocutionsFile_get, _freeling.maco_options_LocutionsFile_set)
    __swig_setmethods__["QuantitiesFile"] = _freeling.maco_options_QuantitiesFile_set
    __swig_getmethods__["QuantitiesFile"] = _freeling.maco_options_QuantitiesFile_get
    if _newclass:
        QuantitiesFile = _swig_property(_freeling.maco_options_QuantitiesFile_get, _freeling.maco_options_QuantitiesFile_set)
    __swig_setmethods__["AffixFile"] = _freeling.maco_options_AffixFile_set
    __swig_getmethods__["AffixFile"] = _freeling.maco_options_AffixFile_get
    if _newclass:
        AffixFile = _swig_property(_freeling.maco_options_AffixFile_get, _freeling.maco_options_AffixFile_set)
    __swig_setmethods__["CompoundFile"] = _freeling.maco_options_CompoundFile_set
    __swig_getmethods__["CompoundFile"] = _freeling.maco_options_CompoundFile_get
    if _newclass:
        CompoundFile = _swig_property(_freeling.maco_options_CompoundFile_get, _freeling.maco_options_CompoundFile_set)
    __swig_setmethods__["DictionaryFile"] = _freeling.maco_options_DictionaryFile_set
    __swig_getmethods__["DictionaryFile"] = _freeling.maco_options_DictionaryFile_get
    if _newclass:
        DictionaryFile = _swig_property(_freeling.maco_options_DictionaryFile_get, _freeling.maco_options_DictionaryFile_set)
    __swig_setmethods__["ProbabilityFile"] = _freeling.maco_options_ProbabilityFile_set
    __swig_getmethods__["ProbabilityFile"] = _freeling.maco_options_ProbabilityFile_get
    if _newclass:
        ProbabilityFile = _swig_property(_freeling.maco_options_ProbabilityFile_get, _freeling.maco_options_ProbabilityFile_set)
    __swig_setmethods__["NPdataFile"] = _freeling.maco_options_NPdataFile_set
    __swig_getmethods__["NPdataFile"] = _freeling.maco_options_NPdataFile_get
    if _newclass:
        NPdataFile = _swig_property(_freeling.maco_options_NPdataFile_get, _freeling.maco_options_NPdataFile_set)
    __swig_setmethods__["PunctuationFile"] = _freeling.maco_options_PunctuationFile_set
    __swig_getmethods__["PunctuationFile"] = _freeling.maco_options_PunctuationFile_get
    if _newclass:
        PunctuationFile = _swig_property(_freeling.maco_options_PunctuationFile_get, _freeling.maco_options_PunctuationFile_set)
    __swig_setmethods__["UserMapFile"] = _freeling.maco_options_UserMapFile_set
    __swig_getmethods__["UserMapFile"] = _freeling.maco_options_UserMapFile_get
    if _newclass:
        UserMapFile = _swig_property(_freeling.maco_options_UserMapFile_get, _freeling.maco_options_UserMapFile_set)
    __swig_setmethods__["Decimal"] = _freeling.maco_options_Decimal_set
    __swig_getmethods__["Decimal"] = _freeling.maco_options_Decimal_get
    if _newclass:
        Decimal = _swig_property(_freeling.maco_options_Decimal_get, _freeling.maco_options_Decimal_set)
    __swig_setmethods__["Thousand"] = _freeling.maco_options_Thousand_set
    __swig_getmethods__["Thousand"] = _freeling.maco_options_Thousand_get
    if _newclass:
        Thousand = _swig_property(_freeling.maco_options_Thousand_get, _freeling.maco_options_Thousand_set)
    __swig_setmethods__["ProbabilityThreshold"] = _freeling.maco_options_ProbabilityThreshold_set
    __swig_getmethods__["ProbabilityThreshold"] = _freeling.maco_options_ProbabilityThreshold_get
    if _newclass:
        ProbabilityThreshold = _swig_property(_freeling.maco_options_ProbabilityThreshold_get, _freeling.maco_options_ProbabilityThreshold_set)
    __swig_setmethods__["InverseDict"] = _freeling.maco_options_InverseDict_set
    __swig_getmethods__["InverseDict"] = _freeling.maco_options_InverseDict_get
    if _newclass:
        InverseDict = _swig_property(_freeling.maco_options_InverseDict_get, _freeling.maco_options_InverseDict_set)
    __swig_setmethods__["RetokContractions"] = _freeling.maco_options_RetokContractions_set
    __swig_getmethods__["RetokContractions"] = _freeling.maco_options_RetokContractions_get
    if _newclass:
        RetokContractions = _swig_property(_freeling.maco_options_RetokContractions_get, _freeling.maco_options_RetokContractions_set)

    def __init__(self, arg2: 'std::wstring const &'):
        this = _freeling.new_maco_options(arg2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_maco_options
    __del__ = lambda self: None

    def set_data_files(self, usr: 'std::wstring const &', pun: 'std::wstring const &', dic: 'std::wstring const &', aff: 'std::wstring const &', comp: 'std::wstring const &', loc: 'std::wstring const &', nps: 'std::wstring const &', qty: 'std::wstring const &', prb: 'std::wstring const &') -> "void":
        return _freeling.maco_options_set_data_files(self, usr, pun, dic, aff, comp, loc, nps, qty, prb)

    def set_nummerical_points(self, dec: 'std::wstring const &', tho: 'std::wstring const &') -> "void":
        return _freeling.maco_options_set_nummerical_points(self, dec, tho)

    def set_threshold(self, arg2: 'double') -> "void":
        return _freeling.maco_options_set_threshold(self, arg2)

    def set_inverse_dict(self, arg2: 'bool') -> "void":
        return _freeling.maco_options_set_inverse_dict(self, arg2)

    def set_retok_contractions(self, arg2: 'bool') -> "void":
        return _freeling.maco_options_set_retok_contractions(self, arg2)
maco_options_swigregister = _freeling.maco_options_swigregister
maco_options_swigregister(maco_options)

class maco(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, maco, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, maco, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'maco_options'):
        this = _freeling.new_maco(arg2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_maco
    __del__ = lambda self: None

    def set_active_options(self, umap: 'bool', num: 'bool', pun: 'bool', dat: 'bool', dic: 'bool', aff: 'bool', comp: 'bool', rtk: 'bool', mw: 'bool', ner: 'bool', qt: 'bool', prb: 'bool') -> "void":
        return _freeling.maco_set_active_options(self, umap, num, pun, dat, dic, aff, comp, rtk, mw, ner, qt, prb)

    def analyze(self, *args) -> "freeling::document":
        return _freeling.maco_analyze(self, *args)
maco_swigregister = _freeling.maco_swigregister
maco_swigregister(maco)

class RE_map(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RE_map, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RE_map, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &'):
        this = _freeling.new_RE_map(arg2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_RE_map
    __del__ = lambda self: None

    def annotate_word(self, arg2: 'word') -> "void":
        return _freeling.RE_map_annotate_word(self, arg2)

    def analyze(self, *args) -> "freeling::document":
        return _freeling.RE_map_analyze(self, *args)
RE_map_swigregister = _freeling.RE_map_swigregister
RE_map_swigregister(RE_map)

class numbers(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, numbers, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, numbers, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &', arg3: 'std::wstring const &', arg4: 'std::wstring const &'):
        this = _freeling.new_numbers(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_numbers
    __del__ = lambda self: None

    def analyze(self, *args) -> "freeling::document":
        return _freeling.numbers_analyze(self, *args)
numbers_swigregister = _freeling.numbers_swigregister
numbers_swigregister(numbers)

class punts(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, punts, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, punts, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &'):
        this = _freeling.new_punts(arg2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_punts
    __del__ = lambda self: None

    def analyze(self, *args) -> "freeling::document":
        return _freeling.punts_analyze(self, *args)
punts_swigregister = _freeling.punts_swigregister
punts_swigregister(punts)

class dates(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dates, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dates, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &'):
        this = _freeling.new_dates(arg2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_dates
    __del__ = lambda self: None

    def analyze(self, *args) -> "freeling::document":
        return _freeling.dates_analyze(self, *args)
dates_swigregister = _freeling.dates_swigregister
dates_swigregister(dates)

class dictionary(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dictionary, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dictionary, name)
    __repr__ = _swig_repr

    def __init__(self, Lang: 'std::wstring const &', dicFile: 'std::wstring const &', sufFile: 'std::wstring const &', compFile: 'std::wstring const &', invDic: 'bool'=False, retok: 'bool'=True):
        this = _freeling.new_dictionary(Lang, dicFile, sufFile, compFile, invDic, retok)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_dictionary
    __del__ = lambda self: None

    def add_analysis(self, arg2: 'std::wstring const &', arg3: 'analysis') -> "void":
        return _freeling.dictionary_add_analysis(self, arg2, arg3)

    def remove_entry(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.dictionary_remove_entry(self, arg2)

    def set_retokenize_contractions(self, arg2: 'bool') -> "void":
        return _freeling.dictionary_set_retokenize_contractions(self, arg2)

    def set_affix_analysis(self, arg2: 'bool') -> "void":
        return _freeling.dictionary_set_affix_analysis(self, arg2)

    def set_compound_analysis(self, arg2: 'bool') -> "void":
        return _freeling.dictionary_set_compound_analysis(self, arg2)

    def has_affixes(self) -> "bool":
        return _freeling.dictionary_has_affixes(self)

    def has_compounds(self) -> "bool":
        return _freeling.dictionary_has_compounds(self)

    def search_form(self, arg2: 'std::wstring const &', arg3: 'ListAnalysis') -> "void":
        return _freeling.dictionary_search_form(self, arg2, arg3)

    def annotate_word(self, *args) -> "void":
        return _freeling.dictionary_annotate_word(self, *args)

    def get_forms(self, arg2: 'std::wstring const &', arg3: 'std::wstring const &') -> "std::list< std::wstring,std::allocator< std::wstring > >":
        return _freeling.dictionary_get_forms(self, arg2, arg3)

    def analyze(self, *args) -> "freeling::document":
        return _freeling.dictionary_analyze(self, *args)
dictionary_swigregister = _freeling.dictionary_swigregister
dictionary_swigregister(dictionary)

class locutions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, locutions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, locutions, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &'):
        this = _freeling.new_locutions(arg2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_locutions
    __del__ = lambda self: None

    def add_locution(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.locutions_add_locution(self, arg2)

    def set_OnlySelected(self, arg2: 'bool') -> "void":
        return _freeling.locutions_set_OnlySelected(self, arg2)

    def analyze(self, *args) -> "freeling::document":
        return _freeling.locutions_analyze(self, *args)
locutions_swigregister = _freeling.locutions_swigregister
locutions_swigregister(locutions)

class ner(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ner, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ner, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &'):
        this = _freeling.new_ner(arg2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_ner
    __del__ = lambda self: None

    def analyze(self, *args) -> "freeling::document":
        return _freeling.ner_analyze(self, *args)
ner_swigregister = _freeling.ner_swigregister
ner_swigregister(ner)

class quantities(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, quantities, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, quantities, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &', arg3: 'std::wstring const &'):
        this = _freeling.new_quantities(arg2, arg3)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_quantities
    __del__ = lambda self: None

    def analyze(self, *args) -> "freeling::document":
        return _freeling.quantities_analyze(self, *args)
quantities_swigregister = _freeling.quantities_swigregister
quantities_swigregister(quantities)

class probabilities(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, probabilities, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, probabilities, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &', arg3: 'double'):
        this = _freeling.new_probabilities(arg2, arg3)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_probabilities
    __del__ = lambda self: None

    def annotate_word(self, arg2: 'word') -> "void":
        return _freeling.probabilities_annotate_word(self, arg2)

    def set_activate_guesser(self, arg2: 'bool') -> "void":
        return _freeling.probabilities_set_activate_guesser(self, arg2)

    def analyze(self, *args) -> "freeling::document":
        return _freeling.probabilities_analyze(self, *args)
probabilities_swigregister = _freeling.probabilities_swigregister
probabilities_swigregister(probabilities)

class hmm_tagger(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, hmm_tagger, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, hmm_tagger, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &', arg3: 'bool', arg4: 'unsigned int', kb: 'unsigned int'=1):
        this = _freeling.new_hmm_tagger(arg2, arg3, arg4, kb)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_hmm_tagger
    __del__ = lambda self: None

    def SequenceProb_log(self, arg2: 'sentence', k: 'int'=0) -> "double":
        return _freeling.hmm_tagger_SequenceProb_log(self, arg2, k)

    def analyze(self, *args) -> "freeling::document":
        return _freeling.hmm_tagger_analyze(self, *args)
hmm_tagger_swigregister = _freeling.hmm_tagger_swigregister
hmm_tagger_swigregister(hmm_tagger)

class relax_tagger(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, relax_tagger, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, relax_tagger, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &', arg3: 'int', arg4: 'double', arg5: 'double', arg6: 'bool', arg7: 'unsigned int'):
        this = _freeling.new_relax_tagger(arg2, arg3, arg4, arg5, arg6, arg7)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_relax_tagger
    __del__ = lambda self: None

    def analyze(self, *args) -> "freeling::document":
        return _freeling.relax_tagger_analyze(self, *args)
relax_tagger_swigregister = _freeling.relax_tagger_swigregister
relax_tagger_swigregister(relax_tagger)

class alternatives(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, alternatives, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, alternatives, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &'):
        this = _freeling.new_alternatives(arg2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_alternatives
    __del__ = lambda self: None

    def get_similar_words(self, arg2: 'std::wstring const &', arg3: 'ListAlternative') -> "void":
        return _freeling.alternatives_get_similar_words(self, arg2, arg3)

    def analyze(self, *args) -> "freeling::document":
        return _freeling.alternatives_analyze(self, *args)
alternatives_swigregister = _freeling.alternatives_swigregister
alternatives_swigregister(alternatives)

class phonetics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, phonetics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, phonetics, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &'):
        this = _freeling.new_phonetics(arg2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_phonetics
    __del__ = lambda self: None

    def get_sound(self, arg2: 'std::wstring const &') -> "std::wstring":
        return _freeling.phonetics_get_sound(self, arg2)

    def analyze(self, *args) -> "freeling::document":
        return _freeling.phonetics_analyze(self, *args)
phonetics_swigregister = _freeling.phonetics_swigregister
phonetics_swigregister(phonetics)

class nec(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, nec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, nec, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &'):
        this = _freeling.new_nec(arg2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_nec
    __del__ = lambda self: None

    def analyze(self, *args) -> "freeling::document":
        return _freeling.nec_analyze(self, *args)
nec_swigregister = _freeling.nec_swigregister
nec_swigregister(nec)

class chart_parser(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, chart_parser, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, chart_parser, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &'):
        this = _freeling.new_chart_parser(arg2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_chart_parser
    __del__ = lambda self: None

    def get_start_symbol(self) -> "std::wstring":
        return _freeling.chart_parser_get_start_symbol(self)

    def analyze(self, *args) -> "freeling::document":
        return _freeling.chart_parser_analyze(self, *args)
chart_parser_swigregister = _freeling.chart_parser_swigregister
chart_parser_swigregister(chart_parser)

class dep_txala(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dep_txala, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dep_txala, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &', arg3: 'std::wstring const &'):
        this = _freeling.new_dep_txala(arg2, arg3)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_dep_txala
    __del__ = lambda self: None

    def complete_parse_tree(self, *args) -> "void":
        return _freeling.dep_txala_complete_parse_tree(self, *args)

    def analyze(self, *args) -> "freeling::document":
        return _freeling.dep_txala_analyze(self, *args)
dep_txala_swigregister = _freeling.dep_txala_swigregister
dep_txala_swigregister(dep_txala)

class dep_treeler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dep_treeler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dep_treeler, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &'):
        this = _freeling.new_dep_treeler(arg2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_dep_treeler
    __del__ = lambda self: None

    def analyze(self, *args) -> "freeling::document":
        return _freeling.dep_treeler_analyze(self, *args)
dep_treeler_swigregister = _freeling.dep_treeler_swigregister
dep_treeler_swigregister(dep_treeler)

class senses(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, senses, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, senses, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &'):
        this = _freeling.new_senses(arg2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_senses
    __del__ = lambda self: None

    def analyze(self, *args) -> "freeling::document":
        return _freeling.senses_analyze(self, *args)
senses_swigregister = _freeling.senses_swigregister
senses_swigregister(senses)

class relaxcor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, relaxcor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, relaxcor, name)
    __repr__ = _swig_repr

    def __init__(self, fname: 'std::wstring const &'):
        this = _freeling.new_relaxcor(fname)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_relaxcor
    __del__ = lambda self: None

    def set_provide_singletons(self, arg2: 'bool') -> "void":
        return _freeling.relaxcor_set_provide_singletons(self, arg2)

    def get_provide_singletons(self) -> "bool":
        return _freeling.relaxcor_get_provide_singletons(self)

    def analyze(self, arg2: 'document') -> "void":
        return _freeling.relaxcor_analyze(self, arg2)
relaxcor_swigregister = _freeling.relaxcor_swigregister
relaxcor_swigregister(relaxcor)

class semgraph_extract(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, semgraph_extract, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, semgraph_extract, name)
    __repr__ = _swig_repr

    def __init__(self, erFile: 'std::wstring const &'):
        this = _freeling.new_semgraph_extract(erFile)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_semgraph_extract
    __del__ = lambda self: None

    def extract(self, doc: 'document') -> "void":
        return _freeling.semgraph_extract_extract(self, doc)
semgraph_extract_swigregister = _freeling.semgraph_extract_swigregister
semgraph_extract_swigregister(semgraph_extract)

class ukb(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ukb, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ukb, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &'):
        this = _freeling.new_ukb(arg2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_ukb
    __del__ = lambda self: None

    def analyze(self, *args) -> "freeling::document":
        return _freeling.ukb_analyze(self, *args)
ukb_swigregister = _freeling.ukb_swigregister
ukb_swigregister(ukb)

class sense_info(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, sense_info, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, sense_info, name)
    __repr__ = _swig_repr
    __swig_setmethods__["sense"] = _freeling.sense_info_sense_set
    __swig_getmethods__["sense"] = _freeling.sense_info_sense_get
    if _newclass:
        sense = _swig_property(_freeling.sense_info_sense_get, _freeling.sense_info_sense_set)
    __swig_setmethods__["parents"] = _freeling.sense_info_parents_set
    __swig_getmethods__["parents"] = _freeling.sense_info_parents_get
    if _newclass:
        parents = _swig_property(_freeling.sense_info_parents_get, _freeling.sense_info_parents_set)
    __swig_setmethods__["semfile"] = _freeling.sense_info_semfile_set
    __swig_getmethods__["semfile"] = _freeling.sense_info_semfile_get
    if _newclass:
        semfile = _swig_property(_freeling.sense_info_semfile_get, _freeling.sense_info_semfile_set)
    __swig_setmethods__["words"] = _freeling.sense_info_words_set
    __swig_getmethods__["words"] = _freeling.sense_info_words_get
    if _newclass:
        words = _swig_property(_freeling.sense_info_words_get, _freeling.sense_info_words_set)
    __swig_setmethods__["tonto"] = _freeling.sense_info_tonto_set
    __swig_getmethods__["tonto"] = _freeling.sense_info_tonto_get
    if _newclass:
        tonto = _swig_property(_freeling.sense_info_tonto_get, _freeling.sense_info_tonto_set)
    __swig_setmethods__["sumo"] = _freeling.sense_info_sumo_set
    __swig_getmethods__["sumo"] = _freeling.sense_info_sumo_get
    if _newclass:
        sumo = _swig_property(_freeling.sense_info_sumo_get, _freeling.sense_info_sumo_set)
    __swig_setmethods__["cyc"] = _freeling.sense_info_cyc_set
    __swig_getmethods__["cyc"] = _freeling.sense_info_cyc_get
    if _newclass:
        cyc = _swig_property(_freeling.sense_info_cyc_get, _freeling.sense_info_cyc_set)

    def __init__(self, arg2: 'std::wstring const &', arg3: 'std::wstring const &'):
        this = _freeling.new_sense_info(arg2, arg3)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_parents_string(self) -> "std::wstring":
        return _freeling.sense_info_get_parents_string(self)
    __swig_destroy__ = _freeling.delete_sense_info
    __del__ = lambda self: None
sense_info_swigregister = _freeling.sense_info_swigregister
sense_info_swigregister(sense_info)

class semanticDB(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, semanticDB, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, semanticDB, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::wstring const &'):
        this = _freeling.new_semanticDB(arg2)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_semanticDB
    __del__ = lambda self: None

    def get_WN_keys(self, arg2: 'std::wstring const &', arg3: 'std::wstring const &', arg4: 'std::wstring const &', arg5: 'std::list< std::pair< std::wstring,std::wstring >,std::allocator< std::pair< std::wstring,std::wstring > > > &') -> "void":
        return _freeling.semanticDB_get_WN_keys(self, arg2, arg3, arg4, arg5)

    def get_sense_words(self, arg2: 'std::wstring const &') -> "std::list< std::wstring,std::allocator< std::wstring > >":
        return _freeling.semanticDB_get_sense_words(self, arg2)

    def get_word_senses(self, arg2: 'std::wstring const &', arg3: 'std::wstring const &', arg4: 'std::wstring const &') -> "std::list< std::wstring,std::allocator< std::wstring > >":
        return _freeling.semanticDB_get_word_senses(self, arg2, arg3, arg4)

    def get_sense_info(self, arg2: 'std::wstring const &') -> "freeling::sense_info":
        return _freeling.semanticDB_get_sense_info(self, arg2)
semanticDB_swigregister = _freeling.semanticDB_swigregister
semanticDB_swigregister(semanticDB)

class tagset(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, tagset, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, tagset, name)
    __repr__ = _swig_repr

    def __init__(self, f: 'std::wstring const &'):
        this = _freeling.new_tagset(f)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_tagset
    __del__ = lambda self: None

    def get_short_tag(self, tag: 'std::wstring const &') -> "std::wstring":
        return _freeling.tagset_get_short_tag(self, tag)

    def get_msd_features_map(self, tag: 'std::wstring const &') -> "std::map< std::wstring,std::wstring,std::less< std::wstring >,std::allocator< std::pair< std::wstring const,std::wstring > > >":
        return _freeling.tagset_get_msd_features_map(self, tag)

    def get_msd_features(self, tag: 'std::wstring const &') -> "std::list< std::pair< std::wstring,std::wstring >,std::allocator< std::pair< std::wstring,std::wstring > > >":
        return _freeling.tagset_get_msd_features(self, tag)

    def get_msd_string(self, tag: 'std::wstring const &') -> "std::wstring":
        return _freeling.tagset_get_msd_string(self, tag)

    def msd_to_tag(self, *args) -> "std::wstring":
        return _freeling.tagset_msd_to_tag(self, *args)
tagset_swigregister = _freeling.tagset_swigregister
tagset_swigregister(tagset)

class foma_FSM(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, foma_FSM, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, foma_FSM, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_foma_FSM(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_foma_FSM
    __del__ = lambda self: None

    def get_similar_words(self, arg2: 'std::wstring const &', arg3: 'ListAlternative') -> "void":
        return _freeling.foma_FSM_get_similar_words(self, arg2, arg3)

    def set_cutoff_threshold(self, arg2: 'int') -> "void":
        return _freeling.foma_FSM_set_cutoff_threshold(self, arg2)

    def set_num_matches(self, arg2: 'int') -> "void":
        return _freeling.foma_FSM_set_num_matches(self, arg2)

    def set_basic_operation_cost(self, arg2: 'int') -> "void":
        return _freeling.foma_FSM_set_basic_operation_cost(self, arg2)

    def set_operation_cost(self, arg2: 'std::wstring const &', arg3: 'std::wstring const &', arg4: 'int') -> "void":
        return _freeling.foma_FSM_set_operation_cost(self, arg2, arg3, arg4)

    def get_alphabet(self) -> "std::set< std::wstring,std::less< std::wstring >,std::allocator< std::wstring > >":
        return _freeling.foma_FSM_get_alphabet(self)
foma_FSM_swigregister = _freeling.foma_FSM_swigregister
foma_FSM_swigregister(foma_FSM)

class fex(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fex, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fex, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_fex(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_fex
    __del__ = lambda self: None

    def encode_all(self, arg2: 'sentence', arg3: 'VectorSetString', arg4: 'VectorSetInt') -> "void":
        return _freeling.fex_encode_all(self, arg2, arg3, arg4)

    def encode_name(self, *args) -> "std::vector< std::set< std::wstring,std::less< std::wstring >,std::allocator< std::wstring > >,std::allocator< std::set< std::wstring,std::less< std::wstring >,std::allocator< std::wstring > > > >":
        return _freeling.fex_encode_name(self, *args)

    def encode_int(self, *args) -> "std::vector< std::set< int,std::less< int >,std::allocator< int > >,std::allocator< std::set< int,std::less< int >,std::allocator< int > > > >":
        return _freeling.fex_encode_int(self, *args)

    def clear_lexicon(self) -> "void":
        return _freeling.fex_clear_lexicon(self)

    def encode_to_lexicon(self, arg2: 'sentence') -> "void":
        return _freeling.fex_encode_to_lexicon(self, arg2)

    def save_lexicon(self, arg2: 'std::wstring const &', arg3: 'double') -> "void":
        return _freeling.fex_save_lexicon(self, arg2, arg3)
fex_swigregister = _freeling.fex_swigregister
fex_swigregister(fex)

class fex_lexicon(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fex_lexicon, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fex_lexicon, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_fex_lexicon(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def clear_lexicon(self) -> "void":
        return _freeling.fex_lexicon_clear_lexicon(self)

    def add_occurrence(self, arg2: 'std::wstring const &') -> "void":
        return _freeling.fex_lexicon_add_occurrence(self, arg2)

    def save_lexicon(self, arg2: 'std::wstring const &', arg3: 'double') -> "void":
        return _freeling.fex_lexicon_save_lexicon(self, arg2, arg3)

    def get_code(self, arg2: 'std::wstring const &') -> "unsigned int":
        return _freeling.fex_lexicon_get_code(self, arg2)

    def get_freq(self, arg2: 'std::wstring const &') -> "unsigned int":
        return _freeling.fex_lexicon_get_freq(self, arg2)

    def contains_code(self, arg2: 'unsigned int') -> "bool":
        return _freeling.fex_lexicon_contains_code(self, arg2)

    def is_empty(self) -> "bool":
        return _freeling.fex_lexicon_is_empty(self)
    __swig_destroy__ = _freeling.delete_fex_lexicon
    __del__ = lambda self: None
fex_lexicon_swigregister = _freeling.fex_lexicon_swigregister
fex_lexicon_swigregister(fex_lexicon)

class util(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, util, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, util, name)
    __repr__ = _swig_repr
    __swig_getmethods__["init_locale"] = lambda x: _freeling.util_init_locale
    if _newclass:
        init_locale = staticmethod(_freeling.util_init_locale)
    __swig_getmethods__["wstring2int"] = lambda x: _freeling.util_wstring2int
    if _newclass:
        wstring2int = staticmethod(_freeling.util_wstring2int)
    __swig_getmethods__["int2wstring"] = lambda x: _freeling.util_int2wstring
    if _newclass:
        int2wstring = staticmethod(_freeling.util_int2wstring)
    __swig_getmethods__["wstring2double"] = lambda x: _freeling.util_wstring2double
    if _newclass:
        wstring2double = staticmethod(_freeling.util_wstring2double)
    __swig_getmethods__["double2wstring"] = lambda x: _freeling.util_double2wstring
    if _newclass:
        double2wstring = staticmethod(_freeling.util_double2wstring)
    __swig_getmethods__["wstring2longdouble"] = lambda x: _freeling.util_wstring2longdouble
    if _newclass:
        wstring2longdouble = staticmethod(_freeling.util_wstring2longdouble)
    __swig_getmethods__["longdouble2wstring"] = lambda x: _freeling.util_longdouble2wstring
    if _newclass:
        longdouble2wstring = staticmethod(_freeling.util_longdouble2wstring)
    __swig_getmethods__["vector2wstring"] = lambda x: _freeling.util_vector2wstring
    if _newclass:
        vector2wstring = staticmethod(_freeling.util_vector2wstring)
    __swig_getmethods__["list2wstring"] = lambda x: _freeling.util_list2wstring
    if _newclass:
        list2wstring = staticmethod(_freeling.util_list2wstring)
    __swig_getmethods__["pairlist2wstring"] = lambda x: _freeling.util_pairlist2wstring
    if _newclass:
        pairlist2wstring = staticmethod(_freeling.util_pairlist2wstring)
    __swig_getmethods__["wstring2list"] = lambda x: _freeling.util_wstring2list
    if _newclass:
        wstring2list = staticmethod(_freeling.util_wstring2list)
    __swig_getmethods__["wstring2vector"] = lambda x: _freeling.util_wstring2vector
    if _newclass:
        wstring2vector = staticmethod(_freeling.util_wstring2vector)
    __swig_getmethods__["capitalization"] = lambda x: _freeling.util_capitalization
    if _newclass:
        capitalization = staticmethod(_freeling.util_capitalization)
    __swig_getmethods__["capitalize"] = lambda x: _freeling.util_capitalize
    if _newclass:
        capitalize = staticmethod(_freeling.util_capitalize)
    __swig_getmethods__["lowercase"] = lambda x: _freeling.util_lowercase
    if _newclass:
        lowercase = staticmethod(_freeling.util_lowercase)
    __swig_getmethods__["uppercase"] = lambda x: _freeling.util_uppercase
    if _newclass:
        uppercase = staticmethod(_freeling.util_uppercase)

    def __init__(self):
        this = _freeling.new_util()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_util
    __del__ = lambda self: None
util_swigregister = _freeling.util_swigregister
util_swigregister(util)

def util_init_locale(arg2: 'std::wstring const &') -> "void":
    return _freeling.util_init_locale(arg2)
util_init_locale = _freeling.util_init_locale

def util_wstring2int(arg2: 'std::wstring const &') -> "int":
    return _freeling.util_wstring2int(arg2)
util_wstring2int = _freeling.util_wstring2int

def util_int2wstring(arg2: 'int const') -> "std::wstring":
    return _freeling.util_int2wstring(arg2)
util_int2wstring = _freeling.util_int2wstring

def util_wstring2double(arg2: 'std::wstring const &') -> "double":
    return _freeling.util_wstring2double(arg2)
util_wstring2double = _freeling.util_wstring2double

def util_double2wstring(arg2: 'double const') -> "std::wstring":
    return _freeling.util_double2wstring(arg2)
util_double2wstring = _freeling.util_double2wstring

def util_wstring2longdouble(arg2: 'std::wstring const &') -> "long double":
    return _freeling.util_wstring2longdouble(arg2)
util_wstring2longdouble = _freeling.util_wstring2longdouble

def util_longdouble2wstring(arg2: 'long double const') -> "std::wstring":
    return _freeling.util_longdouble2wstring(arg2)
util_longdouble2wstring = _freeling.util_longdouble2wstring

def util_vector2wstring(arg2: 'VectorString', arg3: 'std::wstring const &') -> "std::wstring":
    return _freeling.util_vector2wstring(arg2, arg3)
util_vector2wstring = _freeling.util_vector2wstring

def util_list2wstring(arg2: 'ListString', arg3: 'std::wstring const &') -> "std::wstring":
    return _freeling.util_list2wstring(arg2, arg3)
util_list2wstring = _freeling.util_list2wstring

def util_pairlist2wstring(*args) -> "std::wstring":
    return _freeling.util_pairlist2wstring(*args)
util_pairlist2wstring = _freeling.util_pairlist2wstring

def util_wstring2list(arg2: 'std::wstring const &', arg3: 'std::wstring const &') -> "std::list< std::wstring,std::allocator< std::wstring > >":
    return _freeling.util_wstring2list(arg2, arg3)
util_wstring2list = _freeling.util_wstring2list

def util_wstring2vector(arg2: 'std::wstring const &', arg3: 'std::wstring const &') -> "std::vector< std::wstring,std::allocator< std::wstring > >":
    return _freeling.util_wstring2vector(arg2, arg3)
util_wstring2vector = _freeling.util_wstring2vector

def util_capitalization(arg2: 'std::wstring const &') -> "int":
    return _freeling.util_capitalization(arg2)
util_capitalization = _freeling.util_capitalization

def util_capitalize(arg2: 'std::wstring const &', arg3: 'int', arg4: 'bool') -> "std::wstring":
    return _freeling.util_capitalize(arg2, arg3, arg4)
util_capitalize = _freeling.util_capitalize

def util_lowercase(arg2: 'std::wstring const &') -> "std::wstring":
    return _freeling.util_lowercase(arg2)
util_lowercase = _freeling.util_lowercase

def util_uppercase(arg2: 'std::wstring const &') -> "std::wstring":
    return _freeling.util_uppercase(arg2)
util_uppercase = _freeling.util_uppercase

class input_conll(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, input_conll, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, input_conll, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_input_conll(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_input_conll
    __del__ = lambda self: None

    def input_sentences(self, lines: 'std::wstring const &', ls: 'ListSentence') -> "void":
        return _freeling.input_conll_input_sentences(self, lines, ls)

    def input_document(self, lines: 'std::wstring const &', doc: 'document') -> "void":
        return _freeling.input_conll_input_document(self, lines, doc)
input_conll_swigregister = _freeling.input_conll_swigregister
input_conll_swigregister(input_conll)

class output_conll(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, output_conll, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, output_conll, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_output_conll(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_output_conll
    __del__ = lambda self: None

    def PrintHeader(self, sout: 'std::wostream &') -> "void":
        return _freeling.output_conll_PrintHeader(self, sout)

    def PrintFooter(self, sout: 'std::wostream &') -> "void":
        return _freeling.output_conll_PrintFooter(self, sout)

    def PrintResults(self, *args) -> "std::wstring":
        return _freeling.output_conll_PrintResults(self, *args)
output_conll_swigregister = _freeling.output_conll_swigregister
output_conll_swigregister(output_conll)

class input_freeling(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, input_freeling, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, input_freeling, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _freeling.new_input_freeling()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_input_freeling
    __del__ = lambda self: None

    def input_sentences(self, lines: 'std::wstring const &', ls: 'ListSentence') -> "void":
        return _freeling.input_freeling_input_sentences(self, lines, ls)
input_freeling_swigregister = _freeling.input_freeling_swigregister
input_freeling_swigregister(input_freeling)

class output_freeling(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, output_freeling, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, output_freeling, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_output_freeling(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_output_freeling
    __del__ = lambda self: None

    def PrintTree(self, sout: 'std::wostream &', n: 'TreeConstPreorderIteratorNode', depth: 'int') -> "void":
        return _freeling.output_freeling_PrintTree(self, sout, n, depth)

    def PrintDepTree(self, sout: 'std::wostream &', n: 'TreeConstPreorderIteratorDepnode', depth: 'int') -> "void":
        return _freeling.output_freeling_PrintDepTree(self, sout, n, depth)

    def PrintPredArgs(self, sout: 'std::wostream &', s: 'sentence') -> "void":
        return _freeling.output_freeling_PrintPredArgs(self, sout, s)

    def PrintWord(self, sout: 'std::wostream &', w: 'word', only_sel: 'bool'=True, probs: 'bool'=True) -> "void":
        return _freeling.output_freeling_PrintWord(self, sout, w, only_sel, probs)

    def PrintCorefs(self, sout: 'std::wostream &', doc: 'document') -> "void":
        return _freeling.output_freeling_PrintCorefs(self, sout, doc)

    def PrintSemgraph(self, sout: 'std::wostream &', doc: 'document') -> "void":
        return _freeling.output_freeling_PrintSemgraph(self, sout, doc)

    def PrintResults(self, *args) -> "std::wstring":
        return _freeling.output_freeling_PrintResults(self, *args)

    def output_senses(self, arg2: 'bool') -> "void":
        return _freeling.output_freeling_output_senses(self, arg2)

    def output_all_senses(self, arg2: 'bool') -> "void":
        return _freeling.output_freeling_output_all_senses(self, arg2)

    def output_phonetics(self, arg2: 'bool') -> "void":
        return _freeling.output_freeling_output_phonetics(self, arg2)

    def output_dep_tree(self, arg2: 'bool') -> "void":
        return _freeling.output_freeling_output_dep_tree(self, arg2)

    def output_corefs(self, arg2: 'bool') -> "void":
        return _freeling.output_freeling_output_corefs(self, arg2)

    def output_semgraph(self, arg2: 'bool') -> "void":
        return _freeling.output_freeling_output_semgraph(self, arg2)
output_freeling_swigregister = _freeling.output_freeling_swigregister
output_freeling_swigregister(output_freeling)

class output_json(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, output_json, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, output_json, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_output_json(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_output_json
    __del__ = lambda self: None

    def PrintResults(self, *args) -> "std::wstring":
        return _freeling.output_json_PrintResults(self, *args)
output_json_swigregister = _freeling.output_json_swigregister
output_json_swigregister(output_json)

class output_naf(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, output_naf, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, output_naf, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_output_naf(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_output_naf
    __del__ = lambda self: None

    def PrintResults(self, *args) -> "std::wstring":
        return _freeling.output_naf_PrintResults(self, *args)

    def PrintHeader(self, sout: 'std::wostream &') -> "void":
        return _freeling.output_naf_PrintHeader(self, sout)

    def PrintFooter(self, sout: 'std::wostream &') -> "void":
        return _freeling.output_naf_PrintFooter(self, sout)

    def ActivateLayer(self, ly: 'std::wstring const &', b: 'bool') -> "void":
        return _freeling.output_naf_ActivateLayer(self, ly, b)
output_naf_swigregister = _freeling.output_naf_swigregister
output_naf_swigregister(output_naf)

class output_train(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, output_train, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, output_train, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _freeling.new_output_train()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_output_train
    __del__ = lambda self: None

    def PrintResults(self, *args) -> "std::wstring":
        return _freeling.output_train_PrintResults(self, *args)
output_train_swigregister = _freeling.output_train_swigregister
output_train_swigregister(output_train)

class output_xml(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, output_xml, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, output_xml, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _freeling.new_output_xml(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _freeling.delete_output_xml
    __del__ = lambda self: None

    def PrintHeader(self, sout: 'std::wostream &') -> "void":
        return _freeling.output_xml_PrintHeader(self, sout)

    def PrintFooter(self, sout: 'std::wostream &') -> "void":
        return _freeling.output_xml_PrintFooter(self, sout)

    def PrintResults(self, *args) -> "std::wstring":
        return _freeling.output_xml_PrintResults(self, *args)
output_xml_swigregister = _freeling.output_xml_swigregister
output_xml_swigregister(output_xml)

# This file is compatible with both classic and new-style classes.


